[
  {
    "label": "bisect",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "bisect",
    "description": "bisect",
    "detail": "bisect",
    "documentation": {}
  },
  {
    "label": "bisect_left",
    "importPath": "bisect",
    "description": "bisect",
    "isExtraImport": true,
    "detail": "bisect",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "OrderedDict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "deque",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "defaultdict",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "Counter",
    "importPath": "collections",
    "description": "collections",
    "isExtraImport": true,
    "detail": "collections",
    "documentation": {}
  },
  {
    "label": "string",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "string",
    "description": "string",
    "detail": "string",
    "documentation": {}
  },
  {
    "label": "sys",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "sys",
    "description": "sys",
    "detail": "sys",
    "documentation": {}
  },
  {
    "label": "operator",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "operator",
    "description": "operator",
    "detail": "operator",
    "documentation": {}
  },
  {
    "label": "math",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "math",
    "description": "math",
    "detail": "math",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "List",
    "importPath": "typing",
    "description": "typing",
    "isExtraImport": true,
    "detail": "typing",
    "documentation": {}
  },
  {
    "label": "functools",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "functools",
    "description": "functools",
    "detail": "functools",
    "documentation": {}
  },
  {
    "label": "partial",
    "importPath": "functools",
    "description": "functools",
    "isExtraImport": true,
    "detail": "functools",
    "documentation": {}
  },
  {
    "label": "cmp_to_key",
    "importPath": "functools",
    "description": "functools",
    "isExtraImport": true,
    "detail": "functools",
    "documentation": {}
  },
  {
    "label": "copy",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "copy",
    "description": "copy",
    "detail": "copy",
    "documentation": {}
  },
  {
    "label": "fractions",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "fractions",
    "description": "fractions",
    "detail": "fractions",
    "documentation": {}
  },
  {
    "label": "product",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "permutations",
    "importPath": "itertools",
    "description": "itertools",
    "isExtraImport": true,
    "detail": "itertools",
    "documentation": {}
  },
  {
    "label": "re",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "re",
    "description": "re",
    "detail": "re",
    "documentation": {}
  },
  {
    "label": "heapq",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "heapq",
    "description": "heapq",
    "detail": "heapq",
    "documentation": {}
  },
  {
    "label": "json",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "json",
    "description": "json",
    "detail": "json",
    "documentation": {}
  },
  {
    "label": "argparse",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "argparse",
    "description": "argparse",
    "detail": "argparse",
    "documentation": {}
  },
  {
    "label": "datetime",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "datetime",
    "description": "datetime",
    "detail": "datetime",
    "documentation": {}
  },
  {
    "label": "os",
    "kind": 6,
    "isExtraImport": true,
    "importPath": "os",
    "description": "os",
    "detail": "os",
    "documentation": {}
  },
  {
    "label": "Path",
    "importPath": "pathlib",
    "description": "pathlib",
    "isExtraImport": true,
    "detail": "pathlib",
    "documentation": {}
  },
  {
    "label": "quote",
    "importPath": "urllib.parse",
    "description": "urllib.parse",
    "isExtraImport": true,
    "detail": "urllib.parse",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "001_two_sum.1",
    "description": "001_two_sum.1",
    "peekOfCode": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        record = {}\n        for i in range(len(nums)):\n            if nums[i] in record:",
    "detail": "001_two_sum.1",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "001_two_sum.two_sum",
    "description": "001_two_sum.two_sum",
    "peekOfCode": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        a = [(i, nums[i]) for i in range(len(nums))]\n        a.sort(key=operator.itemgetter(1))\n        i = 0",
    "detail": "001_two_sum.two_sum",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "002_add_two_numbers.2",
    "description": "002_add_two_numbers.2",
    "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode",
    "detail": "002_add_two_numbers.2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "002_add_two_numbers.2",
    "description": "002_add_two_numbers.2",
    "peekOfCode": "class Solution:\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = current = ListNode(0)\n        carry = 0\n        while l1 or l2 or carry:",
    "detail": "002_add_two_numbers.2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "002_add_two_numbers.add_two_numbers",
    "description": "002_add_two_numbers.add_two_numbers",
    "peekOfCode": "class Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        carry = 0\n        tail = head = None\n        while True:",
    "detail": "002_add_two_numbers.add_two_numbers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "003_longest_substring_without_repeating_chars.03",
    "description": "003_longest_substring_without_repeating_chars.03",
    "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        mapSet = {}\n        start, result = 0, 0\n        for end in range(len(s)):\n            if s[end] in mapSet:",
    "detail": "003_longest_substring_without_repeating_chars.03",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "003_longest_substring_without_repeating_chars.3",
    "description": "003_longest_substring_without_repeating_chars.3",
    "peekOfCode": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        start, d = 0, {}\n        result = 0\n        for i, val in enumerate(s):\n            if val in d and d[val] >= start:\n                start = d[val] + 1\n            d[val] = i\n            result = max(result, i - start + 1)\n        return result",
    "detail": "003_longest_substring_without_repeating_chars.3",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat",
    "description": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat",
    "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # mark the positions of each individual char\n        pos = {}\n        duplicates = set()\n        for i, c in enumerate(s):",
    "detail": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat_TLE",
    "description": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat_TLE",
    "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        # mark the positions of each individual char\n        pos = {}\n        duplicates = set()\n        for i, c in enumerate(s):",
    "detail": "003_longest_substring_without_repeating_chars.longest_substr_without_repeat_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "004_median_of_2_sorted_arrays.4",
    "description": "004_median_of_2_sorted_arrays.4",
    "peekOfCode": "class Solution:\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        m, n = len(nums1), len(nums2)\n        if m > n:\n            return self.findMedianSortedArrays(nums2, nums1)",
    "detail": "004_median_of_2_sorted_arrays.4",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays",
    "peekOfCode": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        total = len(nums1) + len(nums2)\n        isEven = total % 2 == 0\n        idx = total / 2 if not isEven else total / 2 - 1\n        n1, n2 = 0, 0\n        while True:\n            if not nums1:\n                if isEven:\n                    n1, n2 = nums2[idx], nums2[idx + 1]",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n\t\t\"\"\"\n\t\t:type nums1: List[int]\n\t\t:type nums2: List[int]\n\t\t:rtype: float\n\t\t\"\"\"\n\t\tisOdd = (len(nums1)+len(nums2))%2==1\n\t\tif isOdd:\n\t\t\thalf = (len(nums1)+len(nums2))//2",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tisOdd",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\tisOdd = (len(nums1)+len(nums2))%2==1\n\t\tif isOdd:\n\t\t\thalf = (len(nums1)+len(nums2))//2\n\t\telse:\n\t\t\thalf = (len(nums1)+len(nums2))/2\n\t\ta1, a2 = nums1, nums2\n\t\tcount = 0\n\t\trest = half\n\t\twhile True:\n\t\t\tprint a1, a2",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\thalf",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\thalf = (len(nums1)+len(nums2))//2\n\t\telse:\n\t\t\thalf = (len(nums1)+len(nums2))/2\n\t\ta1, a2 = nums1, nums2\n\t\tcount = 0\n\t\trest = half\n\t\twhile True:\n\t\t\tprint a1, a2\n\t\t\tidx1 = rest/2\n\t\t\tif not a1 or not a2:",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\thalf",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\thalf = (len(nums1)+len(nums2))/2\n\t\ta1, a2 = nums1, nums2\n\t\tcount = 0\n\t\trest = half\n\t\twhile True:\n\t\t\tprint a1, a2\n\t\t\tidx1 = rest/2\n\t\t\tif not a1 or not a2:\n\t\t\t\tbreak\n\t\t\tif idx1 >= len(a1):",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tcount",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\tcount = 0\n\t\trest = half\n\t\twhile True:\n\t\t\tprint a1, a2\n\t\t\tidx1 = rest/2\n\t\t\tif not a1 or not a2:\n\t\t\t\tbreak\n\t\t\tif idx1 >= len(a1):\n\t\t\t\tidx1 = len(a1)-1\n\t\t\tnum = a1[idx1]",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\trest",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\trest = half\n\t\twhile True:\n\t\t\tprint a1, a2\n\t\t\tidx1 = rest/2\n\t\t\tif not a1 or not a2:\n\t\t\t\tbreak\n\t\t\tif idx1 >= len(a1):\n\t\t\t\tidx1 = len(a1)-1\n\t\t\tnum = a1[idx1]\n\t\t\tidx2 = bisect_left(a2, num)",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\tidx1",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\tidx1 = rest/2\n\t\t\tif not a1 or not a2:\n\t\t\t\tbreak\n\t\t\tif idx1 >= len(a1):\n\t\t\t\tidx1 = len(a1)-1\n\t\t\tnum = a1[idx1]\n\t\t\tidx2 = bisect_left(a2, num)\n\t\t\tnewcount = idx2+idx1+count\n\t\t\tif newcount==half:\n\t\t\t\tnexts = []",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tidx1",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\tidx1 = len(a1)-1\n\t\t\tnum = a1[idx1]\n\t\t\tidx2 = bisect_left(a2, num)\n\t\t\tnewcount = idx2+idx1+count\n\t\t\tif newcount==half:\n\t\t\t\tnexts = []\n\t\t\t\tif idx1 < len(a1):\n\t\t\t\t\tnexts.append(a1[idx1])\n\t\t\t\tif idx2 < len(a2):\n\t\t\t\t\tnexts.append(a2[idx2])",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\tnum",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\tnum = a1[idx1]\n\t\t\tidx2 = bisect_left(a2, num)\n\t\t\tnewcount = idx2+idx1+count\n\t\t\tif newcount==half:\n\t\t\t\tnexts = []\n\t\t\t\tif idx1 < len(a1):\n\t\t\t\t\tnexts.append(a1[idx1])\n\t\t\t\tif idx2 < len(a2):\n\t\t\t\t\tnexts.append(a2[idx2])\n\t\t\t\tnext = min(nexts)",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\tidx2",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\tidx2 = bisect_left(a2, num)\n\t\t\tnewcount = idx2+idx1+count\n\t\t\tif newcount==half:\n\t\t\t\tnexts = []\n\t\t\t\tif idx1 < len(a1):\n\t\t\t\t\tnexts.append(a1[idx1])\n\t\t\t\tif idx2 < len(a2):\n\t\t\t\t\tnexts.append(a2[idx2])\n\t\t\t\tnext = min(nexts)\n\t\t\t\tif isOdd:",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\tnewcount",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\tnewcount = idx2+idx1+count\n\t\t\tif newcount==half:\n\t\t\t\tnexts = []\n\t\t\t\tif idx1 < len(a1):\n\t\t\t\t\tnexts.append(a1[idx1])\n\t\t\t\tif idx2 < len(a2):\n\t\t\t\t\tnexts.append(a2[idx2])\n\t\t\t\tnext = min(nexts)\n\t\t\t\tif isOdd:\n\t\t\t\t\treturn next",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tnexts",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\tnexts = []\n\t\t\t\tif idx1 < len(a1):\n\t\t\t\t\tnexts.append(a1[idx1])\n\t\t\t\tif idx2 < len(a2):\n\t\t\t\t\tnexts.append(a2[idx2])\n\t\t\t\tnext = min(nexts)\n\t\t\t\tif isOdd:\n\t\t\t\t\treturn next\n\t\t\t\telse:\n\t\t\t\t\tfirsts = []",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tnext",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\tnext = min(nexts)\n\t\t\t\tif isOdd:\n\t\t\t\t\treturn next\n\t\t\t\telse:\n\t\t\t\t\tfirsts = []\n\t\t\t\t\tif idx1 > 0:\n\t\t\t\t\t\tfirsts.append(a1[idx1-1])\n\t\t\t\t\tif idx2 > 0:\n\t\t\t\t\t\tfirsts.append(a2[idx2-1])\n\t\t\t\t\tfirst = max(firsts)",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\t\tfirsts",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\t\tfirsts = []\n\t\t\t\t\tif idx1 > 0:\n\t\t\t\t\t\tfirsts.append(a1[idx1-1])\n\t\t\t\t\tif idx2 > 0:\n\t\t\t\t\t\tfirsts.append(a2[idx2-1])\n\t\t\t\t\tfirst = max(firsts)\n\t\t\t\t\treturn (first+next)*0.5\n\t\t\telif newcount > half:\n\t\t\t\ta1, a2 = a2, a1\n\t\t\telse:",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\t\tfirst",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\t\tfirst = max(firsts)\n\t\t\t\t\treturn (first+next)*0.5\n\t\t\telif newcount > half:\n\t\t\t\ta1, a2 = a2, a1\n\t\t\telse:\n\t\t\t\tcount = newcount\n\t\t\t\trest = half - count\n\t\t\t\ta1, a2 = a2[idx2:], a1[idx1:]\n\t\ta = a1 if a1 else a2\n\t\tif isOdd:",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tcount",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\tcount = newcount\n\t\t\t\trest = half - count\n\t\t\t\ta1, a2 = a2[idx2:], a1[idx1:]\n\t\ta = a1 if a1 else a2\n\t\tif isOdd:\n\t\t\treturn a[rest]\n\t\telse:\n\t\t\treturn (a[rest-1]+a[rest])*0.5",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\t\trest",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\t\t\trest = half - count\n\t\t\t\ta1, a2 = a2[idx2:], a1[idx1:]\n\t\ta = a1 if a1 else a2\n\t\tif isOdd:\n\t\t\treturn a[rest]\n\t\telse:\n\t\t\treturn (a[rest-1]+a[rest])*0.5",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "\t\ta",
    "kind": 5,
    "importPath": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "description": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "peekOfCode": "\t\ta = a1 if a1 else a2\n\t\tif isOdd:\n\t\t\treturn a[rest]\n\t\telse:\n\t\t\treturn (a[rest-1]+a[rest])*0.5",
    "detail": "004_median_of_2_sorted_arrays.median_of_2_sorted_arrays_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "004_median_of_2_sorted_arrays.median_sorted_arrays",
    "description": "004_median_of_2_sorted_arrays.median_sorted_arrays",
    "peekOfCode": "class Solution(object):\n    def getMedian(self, is_odd, array):\n        if is_odd:\n            return array[1]\n        else:\n            return (array[0] + array[1]) * 0.5\n    def getMax(self, a1, i1, a2, i2):\n        if i1 >= len(a1) or i1 < 0:\n            return a2[i2]\n        if i2 >= len(a2) or i2 < 0:",
    "detail": "004_median_of_2_sorted_arrays.median_sorted_arrays",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "005_longest_palindromic_substring.05",
    "description": "005_longest_palindromic_substring.05",
    "peekOfCode": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        dp = [[0 for _ in range(len(s))] for _ in range(len(s))]\n        maxLength, result = 1, \"\"\n        for index in range(len(s)):\n            dp[index][index] = 1",
    "detail": "005_longest_palindromic_substring.05",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "005_longest_palindromic_substring.05",
    "description": "005_longest_palindromic_substring.05",
    "peekOfCode": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        def expand(s, left, right):\n            while left >= 0 and right < len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1",
    "detail": "005_longest_palindromic_substring.05",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "005_longest_palindromic_substring.5",
    "description": "005_longest_palindromic_substring.5",
    "peekOfCode": "class Solution:\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        for i in range(len(s)):\n            odd = self.getPalindrome(i, i, s)\n            if len(result) < len(odd):",
    "detail": "005_longest_palindromic_substring.5",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "005_longest_palindromic_substring.longest_panlindrome_substring",
    "description": "005_longest_palindromic_substring.longest_panlindrome_substring",
    "peekOfCode": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        longest = \"\"\n        maxlen = 0\n        for i in range(len(s)):\n            start = i",
    "detail": "005_longest_palindromic_substring.longest_panlindrome_substring",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "005_longest_palindromic_substring.longest_panlindromic_string_TE",
    "description": "005_longest_palindromic_substring.longest_panlindromic_string_TE",
    "peekOfCode": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        # A char -> [list of indice]\n        matrix = defaultdict(bool)\n        result = \"\"\n        # initialize",
    "detail": "005_longest_palindromic_substring.longest_panlindromic_string_TE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "006_zigzag_conversion.06",
    "description": "006_zigzag_conversion.06",
    "peekOfCode": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if numRows == 1:\n        \treturn s\n        result = [\"\" for _ in range(numRows)]",
    "detail": "006_zigzag_conversion.06",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "006_zigzag_conversion.6",
    "description": "006_zigzag_conversion.6",
    "peekOfCode": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        if len(s) <= numRows or numRows == 1:\n            return s\n        result = [\"\"] * numRows",
    "detail": "006_zigzag_conversion.6",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "006_zigzag_conversion.zigzag",
    "description": "006_zigzag_conversion.zigzag",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @param {integer} numRows\n    # @return {string}\n    def convert(self, s, numRows):\n        if numRows == 1:\n            return s\n        lines = defaultdict(str)\n        down = True\n        for i, c in enumerate(s):",
    "detail": "006_zigzag_conversion.zigzag",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "007_reverse_integer.7",
    "description": "007_reverse_integer.7",
    "peekOfCode": "class Solution:\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        result = 0\n        neg = False\n        if x < 0:\n            neg = True",
    "detail": "007_reverse_integer.7",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "007_reverse_integer.reverse_integer",
    "description": "007_reverse_integer.reverse_integer",
    "peekOfCode": "class Solution:\n    # @param {integer} x\n    # @return {integer}\n    def reverse(self, x):\n        neg = False\n        if x<0:\n            neg =True\n            x = -x\n        print x\n        reversed_int = int(''.join(reversed(str(x))))",
    "detail": "007_reverse_integer.reverse_integer",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "008_string_to_integer.8",
    "description": "008_string_to_integer.8",
    "peekOfCode": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        MAX, MIN = 2147483647, -2147483648\n        if str == \"\":\n            return 0\n        str = str.strip()  # remove white space",
    "detail": "008_string_to_integer.8",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "008_string_to_integer.atoi",
    "description": "008_string_to_integer.atoi",
    "peekOfCode": "class Solution(object):\n    def myAtoi(self, str):\n        \"\"\"\n        :type str: str\n        :rtype: int\n        \"\"\"\n        str = str.strip()\n        if not str:\n            return 0\n        start = 0",
    "detail": "008_string_to_integer.atoi",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "009_palindrome_number.9",
    "description": "009_palindrome_number.9",
    "peekOfCode": "class Solution:\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        # O(log_n)\n        if x < 0 or (x != 0 and x % 10 == 0):\n            return False\n        rev = 0",
    "detail": "009_palindrome_number.9",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "009_palindrome_number.palindrome_number",
    "description": "009_palindrome_number.palindrome_number",
    "peekOfCode": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        if x == 0:\n            return True\n        if x < 0 or x % 10 == 0:\n            return False",
    "detail": "009_palindrome_number.palindrome_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "010_regular_expression_matching.10",
    "description": "010_regular_expression_matching.10",
    "peekOfCode": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        m, n = len(s), len(p)\n        if n >= 1 and p[0] == \"*\":\n            return False\n        prev = [True]\n        for j in range(n):\n            prev.append(prev[j - 1] and p[j] == \"*\")\n        for i in range(m):\n            curr = [False]",
    "detail": "010_regular_expression_matching.10",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "010_regular_expression_matching.regular_expression_matching",
    "description": "010_regular_expression_matching.regular_expression_matching",
    "peekOfCode": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        # build a list of tuples (char, number)\n        patterns = []\n        i = 0",
    "detail": "010_regular_expression_matching.regular_expression_matching",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "011_container_with_most_water.11",
    "description": "011_container_with_most_water.11",
    "peekOfCode": "class Solution:\n    def maxArea(self, height: List[int]) -> int:\n        l, r = 0, len(height) - 1\n        result = 0\n        while l <= r:\n            if height[l] <= height[r]:\n                h = height[l]\n                result = max(result, (r - l) * h)\n                l += 1\n            else:",
    "detail": "011_container_with_most_water.11",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "011_container_with_most_water.11",
    "description": "011_container_with_most_water.11",
    "peekOfCode": "class Solution:\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height or len(height) < 2:\n            return 0\n        l, r = 0, len(height) - 1\n        res = 0",
    "detail": "011_container_with_most_water.11",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "011_container_with_most_water.container_with_most-water_NxN",
    "description": "011_container_with_most_water.container_with_most-water_NxN",
    "peekOfCode": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        ascending = []\n        last = 0\n        for i, h in enumerate(height):\n            if h > last:",
    "detail": "011_container_with_most_water.container_with_most-water_NxN",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "011_container_with_most_water.container_with_most_water",
    "description": "011_container_with_most_water.container_with_most_water",
    "peekOfCode": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        l = 0\n        r = len(height) - 1\n        _max = 0\n        while l < r:",
    "detail": "011_container_with_most_water.container_with_most_water",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "012_integer_to_roman.12",
    "description": "012_integer_to_roman.12",
    "peekOfCode": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        thousands = [\"\", \"M\", \"MM\", \"MMM\"]\n        hundreds = [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"]\n        tens = [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"]\n        units = [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"]",
    "detail": "012_integer_to_roman.12",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "012_integer_to_roman.integer_to_roman",
    "description": "012_integer_to_roman.integer_to_roman",
    "peekOfCode": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        bases = (\n            (\"I\", 1),\n            (\"V\", 5),\n            (\"X\", 10),",
    "detail": "012_integer_to_roman.integer_to_roman",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "013_roman_to_integer.13",
    "description": "013_roman_to_integer.13",
    "peekOfCode": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        maps = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n        result = 0\n        for i in range(len(s)):\n            if i >= 1 and maps[s[i - 1]] < maps[s[i]]:",
    "detail": "013_roman_to_integer.13",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "013_roman_to_integer.roman_to_integer",
    "description": "013_roman_to_integer.roman_to_integer",
    "peekOfCode": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        nums = (\n            (\"I\", 1),\n            (\"V\", 5),\n            (\"X\", 10),",
    "detail": "013_roman_to_integer.roman_to_integer",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "014_longest_common_prefix.14",
    "description": "014_longest_common_prefix.14",
    "peekOfCode": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        end_index = 0\n        for group in zip(*strs):",
    "detail": "014_longest_common_prefix.14",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "014_longest_common_prefix.longest_common_prefix",
    "description": "014_longest_common_prefix.longest_common_prefix",
    "peekOfCode": "class Solution(object):\n    def longestCommonPrefix(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        if not strs:\n            return \"\"\n        ss = sorted(strs)\n        prefix = ss[0]",
    "detail": "014_longest_common_prefix.longest_common_prefix",
    "documentation": {}
  },
  {
    "label": "longestCommonPrefix",
    "kind": 2,
    "importPath": "014_longest_common_prefix.simple",
    "description": "014_longest_common_prefix.simple",
    "peekOfCode": "def longestCommonPrefix(self, strs):\n    if not strs:\n        return \"\"\n    i = 0\n    while i < len(min(strs, key=len)):\n        if len({s[i] for s in strs}) != 1:\n            break\n        i += 1\n    return strs[0][:i]",
    "detail": "014_longest_common_prefix.simple",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "015_three_sum.15",
    "description": "015_three_sum.15",
    "peekOfCode": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:",
    "detail": "015_three_sum.15",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "015_three_sum.three_sum",
    "description": "015_three_sum.three_sum",
    "peekOfCode": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        nums = sorted(nums)\n        n = 0",
    "detail": "015_three_sum.three_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "016_three_sum_closest.16",
    "description": "016_three_sum_closest.16",
    "peekOfCode": "class Solution:\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        result = float(\"inf\")\n        for i in range(len(nums) - 2):\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == target:\n                    return target",
    "detail": "016_three_sum_closest.16",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "016_three_sum_closest.three_sum_closest",
    "description": "016_three_sum_closest.three_sum_closest",
    "peekOfCode": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        assert len(nums) >= 3\n        nums = sorted(nums)\n        diff = sys.maxint",
    "detail": "016_three_sum_closest.three_sum_closest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "017_letter_combinations_of_phone_number.17",
    "description": "017_letter_combinations_of_phone_number.17",
    "peekOfCode": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        d = {\n            \"1\": \"\",\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",",
    "detail": "017_letter_combinations_of_phone_number.17",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "017_letter_combinations_of_phone_number.17",
    "description": "017_letter_combinations_of_phone_number.17",
    "peekOfCode": "class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        if not digits:\n            return []\n        d = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",",
    "detail": "017_letter_combinations_of_phone_number.17",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "017_letter_combinations_of_phone_number.letter_combination_of_phone_number",
    "description": "017_letter_combinations_of_phone_number.letter_combination_of_phone_number",
    "peekOfCode": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        map = {\n            \"1\": \"\",\n            \"2\": \"abc\",\n            \"3\": \"def\",",
    "detail": "017_letter_combinations_of_phone_number.letter_combination_of_phone_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "018_four_sum.18",
    "description": "018_four_sum.18",
    "peekOfCode": "class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        nums.sort()\n        result = []\n        for i in range(len(nums) - 3):\n            if i > 0 and nums[i - 1] == nums[i]:\n                continue\n            for j in range(i + 1, len(nums) - 2):\n                if j > i + 1 and nums[j - 1] == nums[j]:\n                    continue",
    "detail": "018_four_sum.18",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "018_four_sum.four_sum",
    "description": "018_four_sum.four_sum",
    "peekOfCode": "class Solution(object):\n    def threeSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        results = set()\n        for i in range(len(nums) - 2):",
    "detail": "018_four_sum.four_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "019_remove_nth_node_from_end.19",
    "description": "019_remove_nth_node_from_end.19",
    "peekOfCode": "class Solution:\n    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n        dummy = p = ListNode(0)\n        dummy.next = head\n        fast, slow = head, dummy\n        for i in range(n):\n            if fast:\n                fast = fast.next\n            else:\n                break",
    "detail": "019_remove_nth_node_from_end.19",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "019_remove_nth_node_from_end.remove_nth_node",
    "description": "019_remove_nth_node_from_end.remove_nth_node",
    "peekOfCode": "class Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        fast = head\n        slow = head\n        for i in range(n):",
    "detail": "019_remove_nth_node_from_end.remove_nth_node",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "020_valid_parentheses.20",
    "description": "020_valid_parentheses.20",
    "peekOfCode": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        maps = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n        stack = []\n        for c in s:\n            if c in maps:",
    "detail": "020_valid_parentheses.20",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "020_valid_parentheses.valid_parentheses",
    "description": "020_valid_parentheses.valid_parentheses",
    "peekOfCode": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        stack = []\n        m = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        for c in s:\n            if c in \"([{\":",
    "detail": "020_valid_parentheses.valid_parentheses",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "021_merge_2_sorted_lists.merge_2_sorted_lists",
    "description": "021_merge_2_sorted_lists.merge_2_sorted_lists",
    "peekOfCode": "class Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not l1:\n            return l2\n        if not l2:",
    "detail": "021_merge_2_sorted_lists.merge_2_sorted_lists",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "022_generate_parentheses.22",
    "description": "022_generate_parentheses.22",
    "peekOfCode": "class Solution:\n    def generateParenthesis(self, n: \"int\") -> \"List[str]\":\n        dp = [[] for _ in range(n + 1)]\n        dp[0].append(\"\")\n        for i in range(n + 1):\n            for j in range(i):\n                dp[i] += [\"(\" + x + \")\" + y for x in dp[j] for y in dp[i - j - 1]]\n        return dp[n]\nclass Solution:\n    def generateParenthesis(self, n: int) -> List[str]:",
    "detail": "022_generate_parentheses.22",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "022_generate_parentheses.22",
    "description": "022_generate_parentheses.22",
    "peekOfCode": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        result = []\n        self.search(n, n, \"\", result)\n        return result\n    def search(self, l, r, s, result):\n        if r < l:\n            return\n        if not l and not r:\n            result.append(s)",
    "detail": "022_generate_parentheses.22",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "022_generate_parentheses.generate_parentheses",
    "description": "022_generate_parentheses.generate_parentheses",
    "peekOfCode": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        self.result = []\n        self.generate(\"\", n, n)\n        return self.result\n    def generate(self, current, left, right):",
    "detail": "022_generate_parentheses.generate_parentheses",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "023_merge_k_sorted_lists.merge_k_lists",
    "description": "023_merge_k_sorted_lists.merge_k_lists",
    "peekOfCode": "class Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        if not lists:\n            return None\n        return self.mergeN(lists)\n    def mergeN(self, lists):",
    "detail": "023_merge_k_sorted_lists.merge_k_lists",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "024_swap_nodes_in_pairs.24",
    "description": "024_swap_nodes_in_pairs.24",
    "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"",
    "detail": "024_swap_nodes_in_pairs.24",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "024_swap_nodes_in_pairs.24",
    "description": "024_swap_nodes_in_pairs.24",
    "peekOfCode": "class Solution:\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = p = ListNode(0)\n        dummy.next = head\n        while head and head.next:\n            curr = head.next",
    "detail": "024_swap_nodes_in_pairs.24",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "024_swap_nodes_in_pairs.swap_nodes_in_pairs",
    "description": "024_swap_nodes_in_pairs.swap_nodes_in_pairs",
    "peekOfCode": "class Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        newHead = None\n        tail = None",
    "detail": "024_swap_nodes_in_pairs.swap_nodes_in_pairs",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "025_reverse_nodes_in_k_group.25",
    "description": "025_reverse_nodes_in_k_group.25",
    "peekOfCode": "class Solution:\n    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:\n        dummy = p = ListNode(0)\n        dummy.next = head\n        l, r = head, head\n        while True:\n            count = 0\n            while r and count < k:\n                r = r.next\n                count += 1",
    "detail": "025_reverse_nodes_in_k_group.25",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "025_reverse_nodes_in_k_group.reverse_nodes_in_k_group",
    "description": "025_reverse_nodes_in_k_group.reverse_nodes_in_k_group",
    "peekOfCode": "class Solution:\n    # @param {ListNode} head\n    # @param {integer} k\n    # @return {ListNode}\n    def reverseKGroup(self, head, k):\n        if k == 1:\n            return head\n        ptr = head\n        tail = None\n        while ptr != None:",
    "detail": "025_reverse_nodes_in_k_group.reverse_nodes_in_k_group",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "026_remove_duplicates_from_sorted_array.26",
    "description": "026_remove_duplicates_from_sorted_array.26",
    "peekOfCode": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        idx = 0\n        for n in nums[1:]:",
    "detail": "026_remove_duplicates_from_sorted_array.26",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "026_remove_duplicates_from_sorted_array.remove_duplicates_from_sorted_array",
    "description": "026_remove_duplicates_from_sorted_array.remove_duplicates_from_sorted_array",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def removeDuplicates(self, nums):\n        if len(nums) < 2:\n            return len(nums)\n        d = defaultdict(int)\n        p = {}\n        idx = 0\n        while idx < len(nums):",
    "detail": "026_remove_duplicates_from_sorted_array.remove_duplicates_from_sorted_array",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "027_remove_element.27",
    "description": "027_remove_element.27",
    "peekOfCode": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        if not nums:\n            return 0\n        idx = 0\n        for n in nums:\n            if n != val:\n                nums[idx] = n\n                idx += 1\n        return idx",
    "detail": "027_remove_element.27",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "027_remove_element.remove_element",
    "description": "027_remove_element.remove_element",
    "peekOfCode": "class Solution(object):\n    def removeElement(self, nums, val):\n        \"\"\"\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        \"\"\"\n        i = len(nums) - 1\n        while i >= 0:\n            if nums[i] == val:",
    "detail": "027_remove_element.remove_element",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "028_implement_strstr.28",
    "description": "028_implement_strstr.28",
    "peekOfCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        if haystack == needle or not needle:\n            return 0\n        if not haystack:\n            return -1\n        for i in range(len(haystack) - len(needle) + 1):\n            for j in range(len(needle)):\n                if haystack[i + j] != needle[j]:\n                    break",
    "detail": "028_implement_strstr.28",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "028_implement_strstr.strstr",
    "description": "028_implement_strstr.strstr",
    "peekOfCode": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        if needle not in haystack:\n            return -1\n        return haystack.index(needle)",
    "detail": "028_implement_strstr.strstr",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "029_divide_2integers.29",
    "description": "029_divide_2integers.29",
    "peekOfCode": "class Solution:\n    def divide(self, dividend: int, divisor: int) -> int:\n        sign = (dividend > 0) == (divisor > 0)\n        dividend, divisor = abs(dividend), abs(divisor)\n        result = 0\n        while dividend >= divisor:\n            temp = 0\n            while dividend >= (divisor << temp + 1):\n                temp += 1\n            result += 1 << temp",
    "detail": "029_divide_2integers.29",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "029_divide_2integers.divide_two_integers",
    "description": "029_divide_2integers.divide_two_integers",
    "peekOfCode": "class Solution:\n    # @param {integer} dividend\n    # @param {integer} divisor\n    # @return {integer}\n    def divide(self, dividend, divisor):\n        result = 0\n        negative = False\n        if dividend > 0 and divisor < 0:\n            divisor = -divisor\n            negative = True",
    "detail": "029_divide_2integers.divide_two_integers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "030_substring_with_cancatenation_all_words.30",
    "description": "030_substring_with_cancatenation_all_words.30",
    "peekOfCode": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words or len(s) == 0 or len(words) == 0:\n            return []\n        m, n = len(words[0]), len(words)\n        result = []\n        d = Counter(words)\n        for start in range(min(m, len(s) - n * m + 1)):\n            new_start = start\n            end = start",
    "detail": "030_substring_with_cancatenation_all_words.30",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "030_substring_with_cancatenation_all_words.substring_concat_all_words",
    "description": "030_substring_with_cancatenation_all_words.substring_concat_all_words",
    "peekOfCode": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        dict = collections.defaultdict(int)\n        for w in words:\n            dict[w] += 1",
    "detail": "030_substring_with_cancatenation_all_words.substring_concat_all_words",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "030_substring_with_cancatenation_all_words.substring_concat_all_words_TLE",
    "description": "030_substring_with_cancatenation_all_words.substring_concat_all_words_TLE",
    "peekOfCode": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        if not s or not words:\n            return []\n        wlen = len(words[0])",
    "detail": "030_substring_with_cancatenation_all_words.substring_concat_all_words_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "031_next_permutation.31",
    "description": "031_next_permutation.31",
    "peekOfCode": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        n = len(nums)\n        i = n - 1\n        while i > 0:\n            if nums[i - 1] < nums[i]:\n                break",
    "detail": "031_next_permutation.31",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "031_next_permutation.39",
    "description": "031_next_permutation.39",
    "peekOfCode": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n        candidates.sort()\n        self.search(candidates, target, [], result)\n        return result\n    def search(self, candidates, target, path, result):\n        if target == 0:\n            result.append(list(path))\n            return",
    "detail": "031_next_permutation.39",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "031_next_permutation.next_permutation",
    "description": "031_next_permutation.next_permutation",
    "peekOfCode": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        split_at = -1\n        for i in range(len(nums) - 1, 0, -1):\n            if nums[i - 1] < nums[i]:\n                split_at = i",
    "detail": "031_next_permutation.next_permutation",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "032_longest_valid_parentheses.32",
    "description": "032_longest_valid_parentheses.32",
    "peekOfCode": "class Solution:\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s or len(s) == 0:\n            return 0\n        stack, result = [], 0\n        for i in range(len(s)):",
    "detail": "032_longest_valid_parentheses.32",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "032_longest_valid_parentheses.longest_valid_parentheses",
    "description": "032_longest_valid_parentheses.longest_valid_parentheses",
    "peekOfCode": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        stack = []\n        maxlen = 0\n        start = -1\n        for i, c in enumerate(s):",
    "detail": "032_longest_valid_parentheses.longest_valid_parentheses",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "032_longest_valid_parentheses.longest_valid_parentheses_TE",
    "description": "032_longest_valid_parentheses.longest_valid_parentheses_TE",
    "peekOfCode": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        i = 0\n        maxlen = 0\n        self.longest = {}\n        while i < len(s):",
    "detail": "032_longest_valid_parentheses.longest_valid_parentheses_TE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "description": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "peekOfCode": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        i = 0\n        maxlen = 0\n        while i<len(s):\n            if s[i]==\")\": ",
    "detail": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "documentation": {}
  },
  {
    "label": "\tfail",
    "kind": 5,
    "importPath": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "description": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "peekOfCode": "\tfail = len(s)\n        while True:\n            if i>=len(s):\n                return right*2, fail\n            if s[i]==\"(\":\n                left +=1\n            else:\n                right += 1\n            if left<right:\n\t\tfail = i",
    "detail": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "documentation": {}
  },
  {
    "label": "\t\tfail",
    "kind": 5,
    "importPath": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "description": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "peekOfCode": "\t\tfail = i\n                return left*2, fail\n            i=i+1",
    "detail": "032_longest_valid_parentheses.longest_valid_parentheses_wrong",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "033_search_in_rotated_sorted_array.33",
    "description": "033_search_in_rotated_sorted_array.33",
    "peekOfCode": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if not nums:\n            return -1\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            if nums[m] == target:\n                return m\n            if nums[m] > nums[r]:",
    "detail": "033_search_in_rotated_sorted_array.33",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "033_search_in_rotated_sorted_array.33",
    "description": "033_search_in_rotated_sorted_array.33",
    "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        l, r = 0, len(nums) - 1",
    "detail": "033_search_in_rotated_sorted_array.33",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "033_search_in_rotated_sorted_array.search_in_rorated_array",
    "description": "033_search_in_rotated_sorted_array.search_in_rorated_array",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer}\n    def search(self, nums, target):\n        if nums[0]<nums[-1]:\n            min_index = 0\n        else:\n            first = nums[0]\n            l = 0",
    "detail": "033_search_in_rotated_sorted_array.search_in_rorated_array",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "034_search_for_a_range.34",
    "description": "034_search_for_a_range.34",
    "peekOfCode": "class Solution:\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if not nums or len(nums) == 0:\n            return [-1, -1]\n        def findGreater(t):",
    "detail": "034_search_for_a_range.34",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "034_search_for_a_range.search_for_range",
    "description": "034_search_for_a_range.search_for_range",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} target\n    # @return {integer[]}\n    def searchRange(self, nums, target):\n        l = bisect.bisect_left(nums, target)\n        r = bisect.bisect_right(nums, target)\n        if l >= len(nums) or nums[l] != target:\n            l = -1\n        if r == 0 or nums[r - 1] != target:",
    "detail": "034_search_for_a_range.search_for_range",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "035_search_insert_position.35",
    "description": "035_search_insert_position.35",
    "peekOfCode": "class Solution:\n    def searchInsert(self, nums: List[int], target: int) -> int:\n        if not nums or target < nums[0]:\n            return 0\n        if nums[-1] < target:\n            return len(nums)\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            m = l + (r - l) // 2\n            if nums[m] == target:",
    "detail": "035_search_insert_position.35",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "035_search_insert_position.search_insert_position",
    "description": "035_search_insert_position.search_insert_position",
    "peekOfCode": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        import bisect\n        return bisect.bisect_left(nums, target)",
    "detail": "035_search_insert_position.search_insert_position",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "036_valid_sudoku.36",
    "description": "036_valid_sudoku.36",
    "peekOfCode": "class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        for row in board:\n            if not self.isValid(row):\n                return False\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        for i in [0, 3, 6]:\n            for j in [0, 3, 6]:",
    "detail": "036_valid_sudoku.36",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "036_valid_sudoku.valid_sudoku",
    "description": "036_valid_sudoku.valid_sudoku",
    "peekOfCode": "class Solution(object):\ndef isValidSudoku(self, board):\n    \"\"\"\n    :type board: List[List[str]]\n    :rtype: bool\n    \"\"\"\n    map_row = [{} for _ in xrange(9)]\n    map_col = [{} for _ in xrange(9)]\n    map_cell = [[{} for _ in xrange(3)] for __ in xrange(3)]\n    for i in xrange(9):",
    "detail": "036_valid_sudoku.valid_sudoku",
    "documentation": {}
  },
  {
    "label": "isValidSudoku",
    "kind": 2,
    "importPath": "036_valid_sudoku.valid_sudoku",
    "description": "036_valid_sudoku.valid_sudoku",
    "peekOfCode": "def isValidSudoku(self, board):\n    \"\"\"\n    :type board: List[List[str]]\n    :rtype: bool\n    \"\"\"\n    map_row = [{} for _ in xrange(9)]\n    map_col = [{} for _ in xrange(9)]\n    map_cell = [[{} for _ in xrange(3)] for __ in xrange(3)]\n    for i in xrange(9):\n        for j in xrange(9):",
    "detail": "036_valid_sudoku.valid_sudoku",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "037_sodoku_solver.37",
    "description": "037_sodoku_solver.37",
    "peekOfCode": "class Solution:\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        self.solve(board)\n    def findEmpty(self, board):\n        for i in range(9):\n            for j in range(9):",
    "detail": "037_sodoku_solver.37",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "037_sodoku_solver.sodoku_solver",
    "description": "037_sodoku_solver.sodoku_solver",
    "peekOfCode": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        self.board = board\n        self.blanks = []\n        for i in range(9):\n        \tfor j in range(9):",
    "detail": "037_sodoku_solver.sodoku_solver",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "038_count_and_say.38",
    "description": "038_count_and_say.38",
    "peekOfCode": "class Solution(object):\n    # standard solution\n    # def countAndSay(self, n):\n    #     \"\"\"\n    #     :type n: int\n    #     :rtype: str\n    #     \"\"\"\n    #     if n < 1: return ''\n    #     sequence = {1: '1', 2: '11', 3: '21', 4: '1211', 5: '111221'}\n    #     if n <= 5: return sequence[n]",
    "detail": "038_count_and_say.38",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "038_count_and_say.count_and_say",
    "description": "038_count_and_say.count_and_say",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {string}\n    def countAndSay(self, n):\n        s = \"1\"\n        for i in range(n - 1):\n            idx = 0\n            news = \"\"\n            for j in range(1, len(s)):\n                if s[j] != s[j - 1]:",
    "detail": "038_count_and_say.count_and_say",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "039_combination_sum.39",
    "description": "039_combination_sum.39",
    "peekOfCode": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n        candidates.sort()\n        self.search(candidates, target, [], result)\n        return result\n    def search(self, candidates, target, path, result):\n        if target == 0:\n            result.append(list(path))\n            return",
    "detail": "039_combination_sum.39",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "039_combination_sum.combination_sum",
    "description": "039_combination_sum.combination_sum",
    "peekOfCode": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        q = [(target, [])]\n        candidates = sorted(candidates)\n        result = []",
    "detail": "039_combination_sum.combination_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "040_combination_sum_ii.combination_sum_ii",
    "description": "040_combination_sum_ii.combination_sum_ii",
    "peekOfCode": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.od = OrderedDict()\n        s = sorted(candidates, reverse=True)\n        for num in s:",
    "detail": "040_combination_sum_ii.combination_sum_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "041_first_missing_positive.41",
    "description": "041_first_missing_positive.41",
    "peekOfCode": "class Solution:\n    def firstMissingPositive(self, nums: List[int]) -> int:\n        if not nums or len(nums) == 0:\n            return 1\n        for i in range(len(nums)):\n            target = nums[i]\n            while target > 0 and target <= len(nums) and nums[target - 1] != target:\n                nums[target - 1], target = target, nums[target - 1]\n        for i in range(len(nums)):\n            if nums[i] != i + 1:",
    "detail": "041_first_missing_positive.41",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "041_first_missing_positive.first_missing_positive",
    "description": "041_first_missing_positive.first_missing_positive",
    "peekOfCode": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        l = len(nums)\n        i = 0\n        while i < l:\n            if nums[i] > 0 and nums[i] <= l and nums[i] != i + 1:",
    "detail": "041_first_missing_positive.first_missing_positive",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "042_trapping_rain_water.42",
    "description": "042_trapping_rain_water.42",
    "peekOfCode": "class Solution:\n    def trap(self, height: \"List[int]\") -> \"int\":\n        result = 0\n        stack = []\n        for i in range(len(height)):\n            while stack and height[i] > height[stack[-1]]:\n                pre = stack.pop()\n                if stack:\n                    h = min(height[stack[-1]], height[i])\n                    result += (h - height[pre]) * (i - 1 - stack[-1])",
    "detail": "042_trapping_rain_water.42",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "042_trapping_rain_water.43",
    "description": "042_trapping_rain_water.43",
    "peekOfCode": "class Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = [0] * (len(num1) + len(num2))\n        tail = len(result) - 1\n        for n1 in reversed(num1):",
    "detail": "042_trapping_rain_water.43",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "042_trapping_rain_water.trapping_rain_water",
    "description": "042_trapping_rain_water.trapping_rain_water",
    "peekOfCode": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        peaks = []\n        lefts = []\n        rights = []\n        for i in range(len(height)):",
    "detail": "042_trapping_rain_water.trapping_rain_water",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "043_multiply_strings.43",
    "description": "043_multiply_strings.43",
    "peekOfCode": "class Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = [0] * (len(num1) + len(num2))\n        tail = len(result) - 1\n        for n1 in reversed(num1):",
    "detail": "043_multiply_strings.43",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "043_multiply_strings.multiply_strings",
    "description": "043_multiply_strings.multiply_strings",
    "peekOfCode": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        if num1[0]=='0' or num2[0]=='0':\n            return \"0\"\n        digits = []",
    "detail": "043_multiply_strings.multiply_strings",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "044_wildcard_matching.44",
    "description": "044_wildcard_matching.44",
    "peekOfCode": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        prev = [True]\n        for i in range(len(p)):\n            prev.append(prev[i] and p[i] == \"*\")",
    "detail": "044_wildcard_matching.44",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "044_wildcard_matching.wildcard_matching",
    "description": "044_wildcard_matching.wildcard_matching",
    "peekOfCode": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        # print s, p\n        if s and not p: return False\n        # print s, p",
    "detail": "044_wildcard_matching.wildcard_matching",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "044_wildcard_matching.wildcard_matching_TLE",
    "description": "044_wildcard_matching.wildcard_matching_TLE",
    "peekOfCode": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        # print s, p\n        pmap = defaultdict(int)\n        for c in p:",
    "detail": "044_wildcard_matching.wildcard_matching_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "045_jump_game_ii.45",
    "description": "045_jump_game_ii.45",
    "peekOfCode": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return 0\n        jumps = 0\n        curr_state, max_state = 0, 0\n        for i, v in enumerate(nums[:-1]):\n            max_state = max(max_state, i + v)\n            if i == curr_state:\n                jumps += 1",
    "detail": "045_jump_game_ii.45",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "045_jump_game_ii.jump_game_ii",
    "description": "045_jump_game_ii.jump_game_ii",
    "peekOfCode": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums or len(nums) == 1:\n            return 0\n        candidates = [0]\n        step = 0",
    "detail": "045_jump_game_ii.jump_game_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "046_permutations.46",
    "description": "046_permutations.46",
    "peekOfCode": "class Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        self.dfs(nums, ret, [])\n        return ret\n    def dfs(self, nums, ret, permutation):",
    "detail": "046_permutations.46",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "046_permutations.permutations",
    "description": "046_permutations.permutations",
    "peekOfCode": "class Solution(object):\n    def permute(self, nums):\n        return self.sub(nums)\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n    def sub(self, nums):\n        if len(nums) == 0:\n            return [[]]",
    "detail": "046_permutations.permutations",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "047_permutations_ii.55",
    "description": "047_permutations_ii.55",
    "peekOfCode": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        if len(nums) < 2:\n            return True\n        currentEnd, currentFarthest = 0, 0\n        for i in range(len(nums) - 1):\n            currentFarthest = max(i + nums[i], currentFarthest)\n            if i == currentEnd:\n                currentEnd = currentFarthest\n            if currentEnd >= len(nums) - 1:",
    "detail": "047_permutations_ii.55",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "047_permutations_ii.permutations_ii",
    "description": "047_permutations_ii.permutations_ii",
    "peekOfCode": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not nums:\n            return []\n        self.counter = Counter(nums)\n        self.result = []",
    "detail": "047_permutations_ii.permutations_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "048_rotate_image.48",
    "description": "048_rotate_image.48",
    "peekOfCode": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        visited = set()\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if not visited or (i, j) not in visited:",
    "detail": "048_rotate_image.48",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "048_rotate_image.rotate_image",
    "description": "048_rotate_image.rotate_image",
    "peekOfCode": "class Solution:\n    # @param {integer[][]} matrix\n    # @return {void} Do not return anything, modify matrix in-place instead.\n    def rotate(self, matrix):\n        matrix.reverse()\n        for i in range(len(matrix) - 1):\n            for j in range(i + 1, len(matrix)):\n                a, b = matrix[j][i], matrix[i][j]\n                matrix[j][i] = b\n                matrix[i][j] = a",
    "detail": "048_rotate_image.rotate_image",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "049_group_anagrams.anagrams",
    "description": "049_group_anagrams.anagrams",
    "peekOfCode": "class Solution:\n    # @param {string[]} strs\n    # @return {string[]}\n    def anagrams(self, strs):\n        dic = defaultdict(list)\n        for s in strs:\n            d = defaultdict(int)\n            for c in s:\n                d[c] += 1\n            keystr = \"\".join([k + str(d[k]) for k in sorted(d.keys)])",
    "detail": "049_group_anagrams.anagrams",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "049_group_anagrams.group_anagrams",
    "description": "049_group_anagrams.group_anagrams",
    "peekOfCode": "class Solution(object):\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        if len(strs) == 0:\n            return []\n        d = {}\n        for s in strs:",
    "detail": "049_group_anagrams.group_anagrams",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "050_pow_x_n.50",
    "description": "050_pow_x_n.50",
    "peekOfCode": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            if n == -2147483648:\n                n += 2\n            n = -n\n            x = 1 / x\n        return (",
    "detail": "050_pow_x_n.50",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "050_pow_x_n.powx_n",
    "description": "050_pow_x_n.powx_n",
    "peekOfCode": "class Solution(object):\n    def myPow(self, x, n):\n        \"\"\"\n        :type x: float\n        :type n: int\n        :rtype: float\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:",
    "detail": "050_pow_x_n.powx_n",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "051_n_queens.51",
    "description": "051_n_queens.51",
    "peekOfCode": "class Solution:\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                ret.append([\"\".join(r) for r in chessboard])\n                return",
    "detail": "051_n_queens.51",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "051_n_queens.n_queens",
    "description": "051_n_queens.n_queens",
    "peekOfCode": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        perms = []\n        for perm in itertools.permutations(range(n)):\n            diag = set()\n            tdiag = set()",
    "detail": "051_n_queens.n_queens",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "052_n_queens_ii.52",
    "description": "052_n_queens_ii.52",
    "peekOfCode": "class Solution:\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        self.ret = 0\n        self.dfs([-1] * n, 0)\n        return self.ret\n    def dfs(self, b, r):",
    "detail": "052_n_queens_ii.52",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "052_n_queens_ii.nqueens_ii",
    "description": "052_n_queens_ii.nqueens_ii",
    "peekOfCode": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        perms = []\n        for perm in itertools.permutations(range(n)):\n            diag = set()\n            tdiag = set()",
    "detail": "052_n_queens_ii.nqueens_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "053_maximum_subarray.53",
    "description": "053_maximum_subarray.53",
    "peekOfCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        result, curr_sum = nums[0], nums[0]\n        for num in nums[1:]:\n            curr_sum = max(num, curr_sum + num)\n            result = max(result, curr_sum)\n        return result",
    "detail": "053_maximum_subarray.53",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "053_maximum_subarray.maximum_subarray",
    "description": "053_maximum_subarray.maximum_subarray",
    "peekOfCode": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        maxsum = None\n        sum = 0\n        current = None\n        for i in nums:",
    "detail": "053_maximum_subarray.maximum_subarray",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "054_spiral_matrix.54",
    "description": "054_spiral_matrix.54",
    "peekOfCode": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix or not matrix[0]:\n            return []\n        m, n = len(matrix), len(matrix[0])\n        rowMin, rowMax, colMin, colMax = 0, m - 1, 0, n - 1\n        result = []\n        while rowMin <= rowMax and colMin <= colMax:\n            for j in range(colMin, colMax + 1):\n                result.append(matrix[rowMin][j])",
    "detail": "054_spiral_matrix.54",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "054_spiral_matrix.spiral_matrix",
    "description": "054_spiral_matrix.spiral_matrix",
    "peekOfCode": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if not matrix:\n            return []\n        m, n = len(matrix), len(matrix[0])\n        deltas = [(0, 1), (1, 0), (0, -1), (-1, 0)]",
    "detail": "054_spiral_matrix.spiral_matrix",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "055_jump_game.jump_game",
    "description": "055_jump_game.jump_game",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def canJump(self, nums):\n    \tmax_reach = 0\n    \tfor i, m in enumerate(nums):\n    \t\tif i>max_reach:\n    \t\t\treturn False\n    \t\tmax_reach = max(max_reach, i+nums[i])\n    \treturn max_reach>=len(nums)-1",
    "detail": "055_jump_game.jump_game",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "055_jump_game.jump_game_TLE",
    "description": "055_jump_game.jump_game_TLE",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def canJump(self, nums):\n    \tdp = {}\n    \tdef canReach(i):\n    \t\tprint i\n    \t\tlast = len(nums)-1\n    \t\tif i>=last:\n    \t\t\treturn True",
    "detail": "055_jump_game.jump_game_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "056_merge_intervals.56",
    "description": "056_merge_intervals.56",
    "peekOfCode": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        if len(intervals) < 2:\n            return intervals\n        intervals = sorted(intervals, key=lambda x: x[0])\n        stack = []\n        for interval in intervals:\n            if stack and stack[-1][1] >= interval[0]:",
    "detail": "056_merge_intervals.56",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "056_merge_intervals.merge_intervals",
    "description": "056_merge_intervals.merge_intervals",
    "peekOfCode": "class Solution(object):\n    def merge(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: List[Interval]\n        \"\"\"\n        # sort and merge\n        intervals = sorted(intervals, key=operator.attrgetter(\"start\"))\n        i = 0\n        while i < len(intervals) - 1:",
    "detail": "056_merge_intervals.merge_intervals",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "057_insert_interval.57",
    "description": "057_insert_interval.57",
    "peekOfCode": "class Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        if not intervals or len(intervals) == 0:\n            return [newInterval]\n        result, i = [], 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1",
    "detail": "057_insert_interval.57",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "057_insert_interval.insert_interval",
    "description": "057_insert_interval.insert_interval",
    "peekOfCode": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[Interval]\n        :type newInterval: Interval\n        :rtype: List[Interval]\n        \"\"\"\n        i = 0\n        while i < len(intervals) and intervals[i].end < newInterval.start:\n            i += 1",
    "detail": "057_insert_interval.insert_interval",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "058_length_of_last_word.58",
    "description": "058_length_of_last_word.58",
    "peekOfCode": "class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.strip().split(\" \")[-1])",
    "detail": "058_length_of_last_word.58",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "058_length_of_last_word.len_of_last_word",
    "description": "058_length_of_last_word.len_of_last_word",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def lengthOfLastWord(self, s):\n        if not s.strip():\n            return 0\n        return len(s.strip().split()[-1])",
    "detail": "058_length_of_last_word.len_of_last_word",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "059_spiral_matrix_ii.59",
    "description": "059_spiral_matrix_ii.59",
    "peekOfCode": "class Solution:\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = [[0] * n for _ in range(n)]\n        r, c, dr, dc = 0, 0, 0, 1\n        for i in range(1, n * n + 1):\n            res[r][c] = i",
    "detail": "059_spiral_matrix_ii.59",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "059_spiral_matrix_ii.spiral_matrix",
    "description": "059_spiral_matrix_ii.spiral_matrix",
    "peekOfCode": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n        steps = [n, n - 1, n - 1, n - 2]\n        m = [[0] * n for i in range(n)]\n        dindex = 0",
    "detail": "059_spiral_matrix_ii.spiral_matrix",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "060_permutation_sequence.60",
    "description": "060_permutation_sequence.60",
    "peekOfCode": "class Solution:\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums = list(range(1, n + 1))\n        NN = math.factorial(n)\n        k -= 1",
    "detail": "060_permutation_sequence.60",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "060_permutation_sequence.permutation_sequence",
    "description": "060_permutation_sequence.permutation_sequence",
    "peekOfCode": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        def factorial(m):\n            if m == 1:\n                return 1",
    "detail": "060_permutation_sequence.permutation_sequence",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "061_rotate_list.61",
    "description": "061_rotate_list.61",
    "peekOfCode": "class Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return []\n        l = 1",
    "detail": "061_rotate_list.61",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "061_rotate_list.rotate_list",
    "description": "061_rotate_list.rotate_list",
    "peekOfCode": "class Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        n = 0",
    "detail": "061_rotate_list.rotate_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "062_unique_paths.62",
    "description": "062_unique_paths.62",
    "peekOfCode": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for row in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[-1]",
    "detail": "062_unique_paths.62",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "062_unique_paths.63",
    "description": "062_unique_paths.63",
    "peekOfCode": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j >= 1:",
    "detail": "062_unique_paths.63",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "062_unique_paths.unique_paths",
    "description": "062_unique_paths.unique_paths",
    "peekOfCode": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        import math\n        return math.factorial(m + n - 2) / (\n            math.factorial(m - 1) * math.factorial(n - 1)",
    "detail": "062_unique_paths.unique_paths",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "063_unique_paths_ii.unique_paths_ii",
    "description": "063_unique_paths_ii.unique_paths_ii",
    "peekOfCode": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        # classical DP\n        m, n = len(obstacleGrid[0]), len(obstacleGrid)\n        mat = [[0 for i in range(m)] for j in range(n)]\n        # first row",
    "detail": "063_unique_paths_ii.unique_paths_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "064_minimum_path_sum.64",
    "description": "064_minimum_path_sum.64",
    "peekOfCode": "class Solution:\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or len(grid) == 0:\n            return 0\n        # Space: O(m*n)\n        # m, n = len(grid), len(grid[0])",
    "detail": "064_minimum_path_sum.64",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "064_minimum_path_sum.66",
    "description": "064_minimum_path_sum.66",
    "peekOfCode": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(digits)):\n            digits[~i] += 1\n            if digits[~i] < 10:\n                return digits",
    "detail": "064_minimum_path_sum.66",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "064_minimum_path_sum.minimum_path_sum",
    "description": "064_minimum_path_sum.minimum_path_sum",
    "peekOfCode": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        self.memo = {}\n        return self.minPath(grid, 0, 0)\n    def minPath(self, grid, x, y):\n        n = len(grid)",
    "detail": "064_minimum_path_sum.minimum_path_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "065_valid_number.65",
    "description": "065_valid_number.65",
    "peekOfCode": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        try:\n            new_num = float(s)\n        except:\n            return False",
    "detail": "065_valid_number.65",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "065_valid_number.65",
    "description": "065_valid_number.65",
    "peekOfCode": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        states = [\n            {\"blank\": 0, \"digit\": 1, \"sign\": 2, \"dot\": 3},\n            {\"digit\": 1, \"dot\": 4, \"e\": 5, \"blank\": 8},\n            {\"digit\": 1, \"dot\": 3},\n            {\"digit\": 4},\n            {\"digit\": 4, \"e\": 5, \"blank\": 8},\n            {\"sign\": 6, \"digit\": 7},\n            {\"digit\": 7},",
    "detail": "065_valid_number.65",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "065_valid_number.valid_number",
    "description": "065_valid_number.valid_number",
    "peekOfCode": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        s = s.strip()\n        if \" \" in s:\n            return False\n        if s.startswith(\"0\") or s.lower().startswith(\"0b\"):",
    "detail": "065_valid_number.valid_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "066_plus_one.66",
    "description": "066_plus_one.66",
    "peekOfCode": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(digits)):\n            digits[~i] += 1\n            if digits[~i] < 10:\n                return digits",
    "detail": "066_plus_one.66",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "066_plus_one.plus_one",
    "description": "066_plus_one.plus_one",
    "peekOfCode": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        i = len(digits) - 1\n        carry = 1\n        while i >= 0:\n            digits[i] = digits[i] + carry",
    "detail": "066_plus_one.plus_one",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "067_add_binary.67",
    "description": "067_add_binary.67",
    "peekOfCode": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        result = \"\"\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(a[i])\n                i -= 1\n            if j >= 0:\n                carry += int(b[j])",
    "detail": "067_add_binary.67",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "067_add_binary.add_binary",
    "description": "067_add_binary.add_binary",
    "peekOfCode": "class Solution:\n    # @param {string} a\n    # @param {string} b\n    # @return {string}\n    def addBinary(self, a, b):\n        return bin(int(a, base=2) + int(b, base=2))[2:]",
    "detail": "067_add_binary.add_binary",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "068_text_justification.68",
    "description": "068_text_justification.68",
    "peekOfCode": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        curr, num_of_chars, result = [], 0, []\n        for word in words:\n            # len(curr) represent the number of spaces following total words\n            if len(curr) + num_of_chars + len(word) > maxWidth:\n                for i in range(maxWidth - num_of_chars):\n                    curr[i % (len(curr) - 1 or 1)] += \" \"\n                result.append(\"\".join(curr))\n                curr = []",
    "detail": "068_text_justification.68",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "068_text_justification.text_justification",
    "description": "068_text_justification.text_justification",
    "peekOfCode": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        lines = []\n        i = 0\n        while i < len(words):",
    "detail": "068_text_justification.text_justification",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "069_sqrt_x.69",
    "description": "069_sqrt_x.69",
    "peekOfCode": "class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n        left, right = 1, x\n        while left <= right:",
    "detail": "069_sqrt_x.69",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "069_sqrt_x.70",
    "description": "069_sqrt_x.70",
    "peekOfCode": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return n\n        s1 = 1\n        s2 = 2\n        for i in range(2, n):\n            s = s1 + s2\n            s1, s2 = s2, s\n        return s2",
    "detail": "069_sqrt_x.70",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "069_sqrt_x.sqrt",
    "description": "069_sqrt_x.sqrt",
    "peekOfCode": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n        if x == 1:\n            return 1",
    "detail": "069_sqrt_x.sqrt",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "070_climbing_stairs.71",
    "description": "070_climbing_stairs.71",
    "peekOfCode": "class Solution:\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:",
    "detail": "070_climbing_stairs.71",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "070_climbing_stairs.climb_stairs",
    "description": "070_climbing_stairs.climb_stairs",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def climbStairs(self, n):\n        ways = {}\n        def getways(m):\n            if m == n - 1:\n                return 1\n            elif m == n - 2:\n                return 2",
    "detail": "070_climbing_stairs.climb_stairs",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "071_simplify_path.71",
    "description": "071_simplify_path.71",
    "peekOfCode": "class Solution:\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:",
    "detail": "071_simplify_path.71",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "071_simplify_path.simplify_path",
    "description": "071_simplify_path.simplify_path",
    "peekOfCode": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        segments = path.split(\"/\")\n        parts = []\n        for seg in segments:",
    "detail": "071_simplify_path.simplify_path",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "072_edit_distance.edit_distance",
    "description": "072_edit_distance.edit_distance",
    "peekOfCode": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        self.w1 = word1\n        self.w2 = word2\n        self.table = {}",
    "detail": "072_edit_distance.edit_distance",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "073_set_matrix_zeros.set_matrix_zeros",
    "description": "073_set_matrix_zeros.set_matrix_zeros",
    "peekOfCode": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        if not matrix:\n            return\n        firstRowContainsZero = 0 in matrix[0]\n        firstColContainsZero = 0 in [matrix[x][0] for x in range(len(matrix))]",
    "detail": "073_set_matrix_zeros.set_matrix_zeros",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "074_search_2d_matrix.74",
    "description": "074_search_2d_matrix.74",
    "peekOfCode": "class Solution:\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return False\n        m, n = len(matrix), len(matrix[0])",
    "detail": "074_search_2d_matrix.74",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "074_search_2d_matrix.search_2d_matrix",
    "description": "074_search_2d_matrix.search_2d_matrix",
    "peekOfCode": "class Solution:\n    # @param {integer[][]} matrix\n    # @param {integer} target\n    # @return {boolean}\n    def searchMatrix(self, matrix, target):\n        row = bisect.bisect_left([r[0] for r in matrix], target)\n        if row == len(matrix):\n            row = row - 1\n        else:\n            if matrix[row][0] == target:",
    "detail": "074_search_2d_matrix.search_2d_matrix",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "075_sort_colors.75",
    "description": "075_sort_colors.75",
    "peekOfCode": "class Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i, j = 0, 0\n        for k in range(len(nums)):\n            v = nums[k]\n            nums[k] = 2",
    "detail": "075_sort_colors.75",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "075_sort_colors.85",
    "description": "075_sort_colors.85",
    "peekOfCode": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or len(matrix[0]) == 0:\n            return 0\n        result, n = 0, len(matrix[0])\n        heights = [0] * (n + 1)\n        for row in matrix:\n            for i in range(n):\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\n            stack = [-1]",
    "detail": "075_sort_colors.85",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def sortColors(self, nums):\n\ttemp = [1 for i in range(len(nums))]\n\tred = 0\n\tblue = len(nums)-1\n\tfor i in range(len(nums)/2):\n\t\tnum = nums[i]\t\n\t\tif num == 0:",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\ttemp",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\ttemp = [1 for i in range(len(nums))]\n\tred = 0\n\tblue = len(nums)-1\n\tfor i in range(len(nums)/2):\n\t\tnum = nums[i]\t\n\t\tif num == 0:\n\t\t\ttemp[red]=0\n\t\t\tred = red+1\n\t\tif num == 2:\n\t\t\ttemp[blue] = 2",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\tred",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\tred = 0\n\tblue = len(nums)-1\n\tfor i in range(len(nums)/2):\n\t\tnum = nums[i]\t\n\t\tif num == 0:\n\t\t\ttemp[red]=0\n\t\t\tred = red+1\n\t\tif num == 2:\n\t\t\ttemp[blue] = 2\n\t\t\tblue -= 1",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\tblue",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\tblue = len(nums)-1\n\tfor i in range(len(nums)/2):\n\t\tnum = nums[i]\t\n\t\tif num == 0:\n\t\t\ttemp[red]=0\n\t\t\tred = red+1\n\t\tif num == 2:\n\t\t\ttemp[blue] = 2\n\t\t\tblue -= 1\n\tnums = temp",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\t\tnum",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\t\tnum = nums[i]\t\n\t\tif num == 0:\n\t\t\ttemp[red]=0\n\t\t\tred = red+1\n\t\tif num == 2:\n\t\t\ttemp[blue] = 2\n\t\t\tblue -= 1\n\tnums = temp",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\t\t\tred",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\t\t\tred = red+1\n\t\tif num == 2:\n\t\t\ttemp[blue] = 2\n\t\t\tblue -= 1\n\tnums = temp",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\t\t\ttemp[blue]",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\t\t\ttemp[blue] = 2\n\t\t\tblue -= 1\n\tnums = temp",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "\tnums",
    "kind": 5,
    "importPath": "075_sort_colors.sort_colors",
    "description": "075_sort_colors.sort_colors",
    "peekOfCode": "\tnums = temp",
    "detail": "075_sort_colors.sort_colors",
    "documentation": {}
  },
  {
    "label": "sortColors",
    "kind": 2,
    "importPath": "075_sort_colors.sort_colors_swap",
    "description": "075_sort_colors.sort_colors_swap",
    "peekOfCode": "def sortColors(self, nums):\n    red, white, blue = 0, 0, len(nums) - 1\n    while white <= blue:\n        if nums[white] == 0:\n            nums[red], nums[white] = nums[white], nums[red]\n            white += 1\n            red += 1\n        elif nums[white] == 1:\n            white += 1\n        else:",
    "detail": "075_sort_colors.sort_colors_swap",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "076_min_window_substring.76",
    "description": "076_min_window_substring.76",
    "peekOfCode": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        d = Counter(t)\n        start, end = 0, 0\n        result = \"\"\n        count = len(d)\n        while end < len(s):\n            c = s[end]\n            if c in d:\n                d[c] -= 1",
    "detail": "076_min_window_substring.76",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "076_min_window_substring.min_window_substring_TLE",
    "description": "076_min_window_substring.min_window_substring_TLE",
    "peekOfCode": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        tail = 0\n        tdict = defaultdict(int)",
    "detail": "076_min_window_substring.min_window_substring_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "077_combinations.77",
    "description": "077_combinations.77",
    "peekOfCode": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        result = []\n        self.dfs(list(range(1, n + 1)), k, [], result)\n        return result\n    def dfs(self, arr, k, path, result):\n        if k < 0:\n            return\n        if k == 0:\n            result.append(path)",
    "detail": "077_combinations.77",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "077_combinations.combinations",
    "description": "077_combinations.combinations",
    "peekOfCode": "class Solution(object):\n    def combine(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: List[List[int]]\n        \"\"\"\n        nums = list(range(1, n + 1))\n        return self.recurse(nums, k)\n    def recurse(self, nums, k):",
    "detail": "077_combinations.combinations",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "078_subsets.78",
    "description": "078_subsets.78",
    "peekOfCode": "class Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i in range(1 << len(nums)):\n            tmp = []\n            for j in range(len(nums)):",
    "detail": "078_subsets.78",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "078_subsets.78",
    "description": "078_subsets.78",
    "peekOfCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        self.backtrack(result, 0, nums, [])\n        return result\n    def backtrack(self, result, idx, nums, path):\n        result.append(path)\n        for i in range(idx, len(nums)):\n            self.backtrack(result, i + 1, nums, path + [nums[i]])",
    "detail": "078_subsets.78",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "078_subsets.subsets",
    "description": "078_subsets.subsets",
    "peekOfCode": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        import itertools\n        result = []\n        for i in range(len(nums) + 1):\n            for combi in itertools.combinations(nums, i):",
    "detail": "078_subsets.subsets",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "079_word_search.79",
    "description": "079_word_search.79",
    "peekOfCode": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, i, j, set(), word, 0):\n                    return True\n        return False\n    def dfs(self, board, x, y, visited, word, idx):\n        if idx == len(word):\n            return True",
    "detail": "079_word_search.79",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "079_word_search.word_search",
    "description": "079_word_search.word_search",
    "peekOfCode": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        d = defaultdict(list)\n        for i in range(len(board)):\n            for j in range(len(board[0])):",
    "detail": "079_word_search.word_search",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "079_word_search.word_search_TLE",
    "description": "079_word_search.word_search_TLE",
    "peekOfCode": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        d = defaultdict(list)\n\tfor i in range(len(board)):\n\t\tfor j in range(len(board[0])):",
    "detail": "079_word_search.word_search_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tchoices",
    "kind": 5,
    "importPath": "079_word_search.word_search_TLE",
    "description": "079_word_search.word_search_TLE",
    "peekOfCode": "\t\tchoices = d[word[0]]\n\telse:\n\t\tchoices = filter(functools.partial(self.ajacent, last), d[word[0]])\n\tif not choices:\n\t\treturn False\n        ret = False\n\tfor c in choices:\n\t\tnewd = copy.deepcopy(d)\n                newd[word[0]].remove(c)\n\t\tret = ret or self.recurse(word[1:], newd, c)",
    "detail": "079_word_search.word_search_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tchoices",
    "kind": 5,
    "importPath": "079_word_search.word_search_TLE",
    "description": "079_word_search.word_search_TLE",
    "peekOfCode": "\t\tchoices = filter(functools.partial(self.ajacent, last), d[word[0]])\n\tif not choices:\n\t\treturn False\n        ret = False\n\tfor c in choices:\n\t\tnewd = copy.deepcopy(d)\n                newd[word[0]].remove(c)\n\t\tret = ret or self.recurse(word[1:], newd, c)\n\t\tif ret:\n\t\t\tbreak",
    "detail": "079_word_search.word_search_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tnewd",
    "kind": 5,
    "importPath": "079_word_search.word_search_TLE",
    "description": "079_word_search.word_search_TLE",
    "peekOfCode": "\t\tnewd = copy.deepcopy(d)\n                newd[word[0]].remove(c)\n\t\tret = ret or self.recurse(word[1:], newd, c)\n\t\tif ret:\n\t\t\tbreak\n\treturn ret",
    "detail": "079_word_search.word_search_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tret",
    "kind": 5,
    "importPath": "079_word_search.word_search_TLE",
    "description": "079_word_search.word_search_TLE",
    "peekOfCode": "\t\tret = ret or self.recurse(word[1:], newd, c)\n\t\tif ret:\n\t\t\tbreak\n\treturn ret",
    "detail": "079_word_search.word_search_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "080_reemove_duplicates_from_sorted_array_ii.80",
    "description": "080_reemove_duplicates_from_sorted_array_ii.80",
    "peekOfCode": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1",
    "detail": "080_reemove_duplicates_from_sorted_array_ii.80",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "080_reemove_duplicates_from_sorted_array_ii.remove_duplicates_from_sorted_array_2",
    "description": "080_reemove_duplicates_from_sorted_array_ii.remove_duplicates_from_sorted_array_2",
    "peekOfCode": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        c = 1\n        for i in range(len(nums) - 1, 0, -1):\n            if nums[i] != nums[i - 1]:\n                c = 1",
    "detail": "080_reemove_duplicates_from_sorted_array_ii.remove_duplicates_from_sorted_array_2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "081_search_in_rotated_sorted_array.81",
    "description": "081_search_in_rotated_sorted_array.81",
    "peekOfCode": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        l, r = 0, len(nums) - 1",
    "detail": "081_search_in_rotated_sorted_array.81",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "081_search_in_rotated_sorted_array.search_in_rotated_sorted",
    "description": "081_search_in_rotated_sorted_array.search_in_rotated_sorted",
    "peekOfCode": "class Solution(object):\n    def search(self, nums, target):\n        l, r = 0, len(nums) - 1\n        while l <= r:\n            mid = l + (r - l) // 2\n            if nums[mid] == target:\n                return True\n            while l < mid and nums[l] == nums[mid]:  # tricky part\n                l += 1\n            # the first half is ordered",
    "detail": "081_search_in_rotated_sorted_array.search_in_rotated_sorted",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "082_remove_duplicates_from_sorted_list.82",
    "description": "082_remove_duplicates_from_sorted_list.82",
    "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = prev = ListNode(0)\n        dummy.next = head\n        while head and head.next:\n            if head.val == head.next.val:",
    "detail": "082_remove_duplicates_from_sorted_list.82",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "082_remove_duplicates_from_sorted_list.remove_duplicates_from_sorted_list",
    "description": "082_remove_duplicates_from_sorted_list.remove_duplicates_from_sorted_list",
    "peekOfCode": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        newhead = newtail = None\n        seen = dict()\n        p = head\n        pp = None",
    "detail": "082_remove_duplicates_from_sorted_list.remove_duplicates_from_sorted_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "083_remove_duplicates_from_sorted_list_ii.83",
    "description": "083_remove_duplicates_from_sorted_list_ii.83",
    "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = prev = ListNode(0)\n        dummy.next = head\n        while head and head.next:\n            if head.val == head.next.val:",
    "detail": "083_remove_duplicates_from_sorted_list_ii.83",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "083_remove_duplicates_from_sorted_list_ii.remove-duplicates-from-sorted-list",
    "description": "083_remove_duplicates_from_sorted_list_ii.remove-duplicates-from-sorted-list",
    "peekOfCode": "class Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return head\n        current = head\n        p = head.next",
    "detail": "083_remove_duplicates_from_sorted_list_ii.remove-duplicates-from-sorted-list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "084_largest_rectangle_in_histogram.84",
    "description": "084_largest_rectangle_in_histogram.84",
    "peekOfCode": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        heights += [0]\n        stack = [-1]\n        result = 0\n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                result = max(result, h * (i - stack[-1] - 1))\n            stack.append(i)",
    "detail": "084_largest_rectangle_in_histogram.84",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "084_largest_rectangle_in_histogram.largest_rectangle",
    "description": "084_largest_rectangle_in_histogram.largest_rectangle",
    "peekOfCode": "class Solution:\n    # @param {integer[]} height\n    # @return {integer}\n    def largestRectangleArea(self, height):\n        areas = {}\n        sorted_height = sorted(list(set(height)))\n        lh = len(height)\n        for i in range(lh):\n            h = height[lh - 1 - i]\n            areas[lh - 1 - i] = {}",
    "detail": "084_largest_rectangle_in_histogram.largest_rectangle",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "084_largest_rectangle_in_histogram.largest_rectangle_in_histogram",
    "description": "084_largest_rectangle_in_histogram.largest_rectangle_in_histogram",
    "peekOfCode": "class Solution(object):\n    # def largestRectangleArea(self, height):\n    #     height.append(0)\n    #     stack = [-1]\n    #     ans = 0\n    #     for i in xrange(len(height)):\n    #         while height[i] < height[stack[-1]]:\n    #             h = height[stack.pop()]\n    #             w = i - stack[-1] - 1\n    #             ans = max(ans, h * w)",
    "detail": "084_largest_rectangle_in_histogram.largest_rectangle_in_histogram",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "085_maximal_rectangle.maximal_rectangle",
    "description": "085_maximal_rectangle.maximal_rectangle",
    "peekOfCode": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        maxa = 0\n        if not matrix:\n            return 0\n        vector = [0]* len(matrix[0])",
    "detail": "085_maximal_rectangle.maximal_rectangle",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "086_partition_list.86",
    "description": "086_partition_list.86",
    "peekOfCode": "class Solution:\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        dummy1 = prev = ListNode(0)\n        dummy2 = after = ListNode(0)\n        while head:",
    "detail": "086_partition_list.86",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "086_partition_list.partition_list",
    "description": "086_partition_list.partition_list",
    "peekOfCode": "class Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        cursor = head\n        precursor = None\n        head1 = tail1 = None",
    "detail": "086_partition_list.partition_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "087_scramble_string.87",
    "description": "087_scramble_string.87",
    "peekOfCode": "class Solution:\n    def __init__(self):\n        self.memo = {}\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        if (s1, s2) in self.memo:",
    "detail": "087_scramble_string.87",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "087_scramble_string.88",
    "description": "087_scramble_string.88",
    "peekOfCode": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        while m > 0 and n > 0:",
    "detail": "087_scramble_string.88",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "087_scramble_string.scramble_string",
    "description": "087_scramble_string.scramble_string",
    "peekOfCode": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        if len(s1) != len(s2) or set(s1) != set(s2):\n            return False\n        if s1 == s2:",
    "detail": "087_scramble_string.scramble_string",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "088_merge_sorted_arry.merge_sorted_array",
    "description": "088_merge_sorted_arry.merge_sorted_array",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums1\n    # @param {integer} m\n    # @param {integer[]} nums2\n    # @param {integer} n\n    # @return {void} Do not return anything, modify nums1 in-place instead.\n    def merge(self, nums1, m, nums2, n):\n        end = len(nums1) - 1\n        while end >= m:\n            del nums1[end]",
    "detail": "088_merge_sorted_arry.merge_sorted_array",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "089_gray_code.gray_code",
    "description": "089_gray_code.gray_code",
    "peekOfCode": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ret = [0]\n        num = 0\n        while True:\n            for i in range(n):",
    "detail": "089_gray_code.gray_code",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "090_subsets_ii.90",
    "description": "090_subsets_ii.90",
    "peekOfCode": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        self.backtrack(sorted(nums), [], result)\n        return result\n    def backtrack(self, nums, path, result):\n        result.append(path)\n        if not nums:\n            return\n        for i in range(len(nums)):",
    "detail": "090_subsets_ii.90",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "090_subsets_ii.subsets_ii",
    "description": "090_subsets_ii.subsets_ii",
    "peekOfCode": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.result = set()\n        for i in range(len(nums) + 1):\n            self.getCombi(nums, i, [])\n        return list(self.result)",
    "detail": "090_subsets_ii.subsets_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "091_decode_ways.91",
    "description": "091_decode_ways.91",
    "peekOfCode": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(n):\n            if s[i] > \"0\":\n                dp[i + 1] += dp[i]\n            if i > 0 and \"10\" <= s[i - 1 : i + 1] <= \"26\":\n                dp[i + 1] += dp[i - 1]",
    "detail": "091_decode_ways.91",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "091_decode_ways.decode_ways",
    "description": "091_decode_ways.decode_ways",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def numDecodings(self, s):\n        if not s:\n            return 0\n        self.memo = {}\n        return self.getCount(s, 0)\n    def getCount(self, s, i):\n        if i in self.memo:",
    "detail": "091_decode_ways.decode_ways",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "092_reversed_linked_list_ii.92",
    "description": "092_reversed_linked_list_ii.92",
    "peekOfCode": "class Solution:\n    def reverseBetween(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None",
    "detail": "092_reversed_linked_list_ii.92",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "092_reversed_linked_list_ii.reversed_linked_list",
    "description": "092_reversed_linked_list_ii.reversed_linked_list",
    "peekOfCode": "class Solution(object):\n    def reverseBetween(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if m == n:\n            return head",
    "detail": "092_reversed_linked_list_ii.reversed_linked_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "093_restore_ip_addresses.93",
    "description": "093_restore_ip_addresses.93",
    "peekOfCode": "class Solution:\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        self.dfs(res, s, 0, \"\", 0)\n        return res\n    def dfs(self, res, s, secNum, sec, idx):",
    "detail": "093_restore_ip_addresses.93",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "093_restore_ip_addresses.restore_ip_address",
    "description": "093_restore_ip_addresses.restore_ip_address",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {string[]}\n    def restoreIpAddresses(self, s):\n        self.memo = {}\n        self.s = s\n        self.buildMemo(4, 0)\n        splits = self.memo[(4,0)]\n        result = []\n        for split in splits:",
    "detail": "093_restore_ip_addresses.restore_ip_address",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "094_binary_tree_inorder.94",
    "description": "094_binary_tree_inorder.94",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]",
    "detail": "094_binary_tree_inorder.94",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "094_binary_tree_inorder.94",
    "description": "094_binary_tree_inorder.94",
    "peekOfCode": "class Solution:\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        return (\n            self.inorderTraversal(root.left)",
    "detail": "094_binary_tree_inorder.94",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "094_binary_tree_inorder.94",
    "description": "094_binary_tree_inorder.94",
    "peekOfCode": "class Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        stack, curr = [], root\n        result = []\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            top = stack.pop()\n            result.append(top.val)",
    "detail": "094_binary_tree_inorder.94",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "094_binary_tree_inorder.binary_tree_inorder_traversal",
    "description": "094_binary_tree_inorder.binary_tree_inorder_traversal",
    "peekOfCode": "class Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        stack = [root]\n        result = []\n        while stack:\n            item = stack.pop()",
    "detail": "094_binary_tree_inorder.binary_tree_inorder_traversal",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "095_unique_binary_search_trees_ii.95",
    "description": "095_unique_binary_search_trees_ii.95",
    "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        if n == 0:\n            return []\n        self.trees = {}",
    "detail": "095_unique_binary_search_trees_ii.95",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "095_unique_binary_search_trees_ii.95",
    "description": "095_unique_binary_search_trees_ii.95",
    "peekOfCode": "class Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        if n == 0:\n            return []\n        self.trees = {}\n        return self.constructTree(1, n)\n    def constructTree(self, start, end):\n        if (start, end) in self.trees:\n            return self.trees[(start, end)]\n        if start > end:",
    "detail": "095_unique_binary_search_trees_ii.95",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "095_unique_binary_search_trees_ii.unique_binary_search_trees_ii",
    "description": "095_unique_binary_search_trees_ii.unique_binary_search_trees_ii",
    "peekOfCode": "class Solution(object):\n    def generateTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[TreeNode]\n        \"\"\"\n        return self.buildTree(0, n)\n    def buildTree(self, n1, n2):\n        if n1 == n2:\n            return [None]",
    "detail": "095_unique_binary_search_trees_ii.unique_binary_search_trees_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "096_unique_binary_search_trees.96",
    "description": "096_unique_binary_search_trees.96",
    "peekOfCode": "class Solution:\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # DP[n]: number of BST of a sequence with length n\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):",
    "detail": "096_unique_binary_search_trees.96",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "096_unique_binary_search_trees.unique_binary_search_trees",
    "description": "096_unique_binary_search_trees.unique_binary_search_trees",
    "peekOfCode": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1",
    "detail": "096_unique_binary_search_trees.unique_binary_search_trees",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "097_interleaving_string.97",
    "description": "097_interleaving_string.97",
    "peekOfCode": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        # m, n = len(s1), len(s2)\n        # if len(s3) != m+n: return False",
    "detail": "097_interleaving_string.97",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "097_interleaving_string.interleaving_dp",
    "description": "097_interleaving_string.interleaving_dp",
    "peekOfCode": "class Solution:\n    # @param {string} s1\n    # @param {string} s2\n    # @param {string} s3\n    # @return {boolean}\n    def isInterleave(self, s1, s2, s3):\n        # first they need the same composition\n        counter = defaultdict(int)\n        for c in s1 + s2:\n            counter[c] += 1",
    "detail": "097_interleaving_string.interleaving_dp",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "class Solution:\n    # @param {string} s1\n    # @param {string} s2\n    # @param {string} s3\n    # @return {boolean}\n    def isInterleave(self, s1, s2, s3):\n        # first they need the same composition\n        counter = defaultdict(int)\n        for c in s1+s2:\n            counter[c]+=1",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "s1",
    "kind": 5,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "s1 = \"aabcc\"\ns2 = \"dbbca\"\ns3 = \"aadbbcbcac\"\nprint Solution().isInterleave(s1, s2, s3)\ns1 = \"abaaacbacaab\"\ns2 = \"bcccababccc\"\ns3 =\"bcccabaaaaabccaccbacabb\"\nprint Solution().isInterleave(s1, s2, s3)",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "s2",
    "kind": 5,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "s2 = \"dbbca\"\ns3 = \"aadbbcbcac\"\nprint Solution().isInterleave(s1, s2, s3)\ns1 = \"abaaacbacaab\"\ns2 = \"bcccababccc\"\ns3 =\"bcccabaaaaabccaccbacabb\"\nprint Solution().isInterleave(s1, s2, s3)",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "s3",
    "kind": 5,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "s3 = \"aadbbcbcac\"\nprint Solution().isInterleave(s1, s2, s3)\ns1 = \"abaaacbacaab\"\ns2 = \"bcccababccc\"\ns3 =\"bcccabaaaaabccaccbacabb\"\nprint Solution().isInterleave(s1, s2, s3)",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "s1",
    "kind": 5,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "s1 = \"abaaacbacaab\"\ns2 = \"bcccababccc\"\ns3 =\"bcccabaaaaabccaccbacabb\"\nprint Solution().isInterleave(s1, s2, s3)",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "s2",
    "kind": 5,
    "importPath": "097_interleaving_string.interleaving_naive",
    "description": "097_interleaving_string.interleaving_naive",
    "peekOfCode": "s2 = \"bcccababccc\"\ns3 =\"bcccabaaaaabccaccbacabb\"\nprint Solution().isInterleave(s1, s2, s3)",
    "detail": "097_interleaving_string.interleaving_naive",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "097_interleaving_string.interleaving_take2",
    "description": "097_interleaving_string.interleaving_take2",
    "peekOfCode": "class Solution:\n    # @param {string} s1\n    # @param {string} s2\n    # @param {string} s3\n    # @return {boolean}\n    def isInterleave(self, s1, s2, s3):\n        # first they need the same composition\n        counter = defaultdict(int)\n        for c in s1+s2:\n            counter[c]+=1",
    "detail": "097_interleaving_string.interleaving_take2",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "098_validate_binary_search_tree.98",
    "description": "098_validate_binary_search_tree.98",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n# class Solution:\n#     def isValidBST(self, root: TreeNode) -> bool:\n#         return self.isValid(root, float('-inf'), float('inf'))\n#     def isValid(self, root, lower, upper):\n#         if not root: return True",
    "detail": "098_validate_binary_search_tree.98",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "098_validate_binary_search_tree.98",
    "description": "098_validate_binary_search_tree.98",
    "peekOfCode": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        stack, curr, prev = [], root, None\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            top = stack.pop()\n            if prev and prev.val >= top.val:\n                return False",
    "detail": "098_validate_binary_search_tree.98",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "098_validate_binary_search_tree.validate_binary_search_tree",
    "description": "098_validate_binary_search_tree.validate_binary_search_tree",
    "peekOfCode": "class Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        a, b, c = self.recurse(root)\n        return c",
    "detail": "098_validate_binary_search_tree.validate_binary_search_tree",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "099_recover_binary_search_tree.99",
    "description": "099_recover_binary_search_tree.99",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n# Space: O(h), where h is the tree height\nclass Solution:\n    def __init__(self):\n        self.prev = TreeNode(float(\"-inf\"))\n        self.first = None",
    "detail": "099_recover_binary_search_tree.99",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "099_recover_binary_search_tree.99",
    "description": "099_recover_binary_search_tree.99",
    "peekOfCode": "class Solution:\n    def __init__(self):\n        self.prev = TreeNode(float(\"-inf\"))\n        self.first = None\n        self.second = None\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.traverse(root)",
    "detail": "099_recover_binary_search_tree.99",
    "documentation": {}
  },
  {
    "label": "Solution1",
    "kind": 6,
    "importPath": "099_recover_binary_search_tree.99",
    "description": "099_recover_binary_search_tree.99",
    "peekOfCode": "class Solution1:\n    def __init__(self):\n        self.previous = TreeNode(float(\"-inf\"))\n        self.first = None\n        self.second = None\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"",
    "detail": "099_recover_binary_search_tree.99",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "099_recover_binary_search_tree.recover_binary_search_tree",
    "description": "099_recover_binary_search_tree.recover_binary_search_tree",
    "peekOfCode": "class Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.lefty = None\n        self.righty = None\n        self._minnode = None\n        self._maxnode = None",
    "detail": "099_recover_binary_search_tree.recover_binary_search_tree",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "100_same_tree.100",
    "description": "100_same_tree.100",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode",
    "detail": "100_same_tree.100",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "100_same_tree.100",
    "description": "100_same_tree.100",
    "peekOfCode": "class Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p or not q:\n            return p == q\n        if p.val != q.val:",
    "detail": "100_same_tree.100",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "100_same_tree.same_tree",
    "description": "100_same_tree.same_tree",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {boolean}\n    def isSameTree(self, p, q):\n        if not p:\n            return not q\n        if not q:\n            return not p\n        if p.val != q.val:",
    "detail": "100_same_tree.same_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.101_symmetric_tree.symmetric_tree",
    "description": "__UNSORTED.101_symmetric_tree.symmetric_tree",
    "peekOfCode": "class Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return True\n        return self.isMirror(root.left, root.right)\n    def isMirror(self, node1, node2):",
    "detail": "__UNSORTED.101_symmetric_tree.symmetric_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.102_binary_tree_level_order_traversal.binary_tree_level_order_traversal",
    "description": "__UNSORTED.102_binary_tree_level_order_traversal.binary_tree_level_order_traversal",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer[][]}\n    def levelOrder(self, root):\n        if not root:\n            return []\n        self.q = deque()\n        self.result = []\n        self.q.append((root, 0))\n        while self.q:",
    "detail": "__UNSORTED.102_binary_tree_level_order_traversal.binary_tree_level_order_traversal",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.103_binary_tree_zigzag_level_order_traversal.binary_tree_zigzag_level_order_traversal",
    "description": "__UNSORTED.103_binary_tree_zigzag_level_order_traversal.binary_tree_zigzag_level_order_traversal",
    "peekOfCode": "class Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        self.levels = []\n        self.recurse(root, 0)\n        result = []\n        for i in range(len(self.levels)):",
    "detail": "__UNSORTED.103_binary_tree_zigzag_level_order_traversal.binary_tree_zigzag_level_order_traversal",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.104_max_depth_of_binary_tree.max_depth_of_binary_tree",
    "description": "__UNSORTED.104_max_depth_of_binary_tree.max_depth_of_binary_tree",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def maxDepth(self, root):\n        if not root:\n            return 0\n        maximum = 1\n        if root.left:\n            maximum = max(maximum, self.maxDepth(root.left) + 1)\n        if root.right:",
    "detail": "__UNSORTED.104_max_depth_of_binary_tree.max_depth_of_binary_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.105_construct_bt_from_preorder_inorder.contruct_binary_tree_from_preorder_inorder",
    "description": "__UNSORTED.105_construct_bt_from_preorder_inorder.contruct_binary_tree_from_preorder_inorder",
    "peekOfCode": "class Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.preorder = preorder\n        self.inorder = inorder\n        full_length = len(preorder)",
    "detail": "__UNSORTED.105_construct_bt_from_preorder_inorder.contruct_binary_tree_from_preorder_inorder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.106_construct_bt_from_postorder_inorder.construct_binary_tree_from_inorder_postorder",
    "description": "__UNSORTED.106_construct_bt_from_postorder_inorder.construct_binary_tree_from_inorder_postorder",
    "peekOfCode": "class Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        self.inorder = inorder\n        self.postorder = postorder\n        return self.recurse(0, len(self.inorder), 0, len(self.postorder))",
    "detail": "__UNSORTED.106_construct_bt_from_postorder_inorder.construct_binary_tree_from_inorder_postorder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.107_binary_tree_level_order_traversal_ii.binary_tree_level_order_traversal_ii",
    "description": "__UNSORTED.107_binary_tree_level_order_traversal_ii.binary_tree_level_order_traversal_ii",
    "peekOfCode": "class Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        self.levels = []\n        self.recurse(root, 0)\n        return self.levels[::-1]\n    def recurse(self, node, lvl):",
    "detail": "__UNSORTED.107_binary_tree_level_order_traversal_ii.binary_tree_level_order_traversal_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.108_sorted_array_to_bst.sorted_array_to_bst",
    "description": "__UNSORTED.108_sorted_array_to_bst.sorted_array_to_bst",
    "peekOfCode": "class Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        tree = self.recurse(nums)\n        return tree\n    def recurse(self, nums):\n        if not nums:",
    "detail": "__UNSORTED.108_sorted_array_to_bst.sorted_array_to_bst",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.109_convert_sorted_list_to_BST.convert_sorted_list_to_BST",
    "description": "__UNSORTED.109_convert_sorted_list_to_BST.convert_sorted_list_to_BST",
    "peekOfCode": "class Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            node = TreeNode(head.val)",
    "detail": "__UNSORTED.109_convert_sorted_list_to_BST.convert_sorted_list_to_BST",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.110_balanced_binary_treee.balanced_binary_tree",
    "description": "__UNSORTED.110_balanced_binary_treee.balanced_binary_tree",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {boolean}\n    def isBalanced(self, root):\n        self.compute_height(root)\n        def get_balance(node):\n            if not node:\n                return True\n            if node.left:\n                l = node.left.height",
    "detail": "__UNSORTED.110_balanced_binary_treee.balanced_binary_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.111_minimum_depth_of_bst.minimum_depth_of_binary_tree",
    "description": "__UNSORTED.111_minimum_depth_of_bst.minimum_depth_of_binary_tree",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def minDepth(self, root):\n        if not root:\n            return 0\n        if not root.left and not root.right:\n            return 1\n        elif not root.left:\n            return self.minDepth(root.right) + 1",
    "detail": "__UNSORTED.111_minimum_depth_of_bst.minimum_depth_of_binary_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.112_path_sum.path_sum",
    "description": "__UNSORTED.112_path_sum.path_sum",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @param {integer} sum\n    # @return {boolean}\n    def hasPathSum(self, root, sum):\n        if not root:\n            return False\n        if not root.left and not root.right:\n            return root.val == sum\n        elif not root.left:",
    "detail": "__UNSORTED.112_path_sum.path_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.113_path_sum_ii.path_sum_ii",
    "description": "__UNSORTED.113_path_sum_ii.path_sum_ii",
    "peekOfCode": "class Solution(object):\n    def pathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.results = []\n        self.recurse(root, sum, [])\n        return self.results",
    "detail": "__UNSORTED.113_path_sum_ii.path_sum_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "description": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "peekOfCode": "class Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.in_order = []\n        self.inorder_traverse(root)\n        for i, node in enumerate(self.in_order[:-1]):\n            node.right = self.in_order[i + 1]",
    "detail": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "description": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "peekOfCode": "class TreeNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\ndef make_tree(_list):\n    if not _list:\n        return\n    val = _list.pop(0)\n    if not val:",
    "detail": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "documentation": {}
  },
  {
    "label": "make_tree",
    "kind": 2,
    "importPath": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "description": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "peekOfCode": "def make_tree(_list):\n    if not _list:\n        return\n    val = _list.pop(0)\n    if not val:\n        return None\n    node = TreeNode(val)\n    node.left = make_tree(_list)\n    node.right = make_tree(_list)\n    return node",
    "detail": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_TLE",
    "description": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_TLE",
    "peekOfCode": "class Solution(object):\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        if not root:\n            return None\n        self.recurse(root)\n    def recurse(self, root):",
    "detail": "__UNSORTED.114_flatten_binary_tree_to_linked_list.flatten_binary_tree_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "description": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {integer}\n    def numDistinct(self, s, t):\n        self.memo = {}\n        self.s = \"\"\n        self.t = t\n        for c in t:\n            if c not in s:",
    "detail": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "documentation": {}
  },
  {
    "label": "s",
    "kind": 5,
    "importPath": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "description": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "peekOfCode": "s = \"anacondastreetracecar\";\nt =  \"contra\"\nprint Solution().numDistinct(s, t)",
    "detail": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "documentation": {}
  },
  {
    "label": "t",
    "kind": 5,
    "importPath": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "description": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "peekOfCode": "t =  \"contra\"\nprint Solution().numDistinct(s, t)",
    "detail": "__UNSORTED.115_distinct_subsequences.distinct_subsequences",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.116_populating_next_right_pointers_in_each_node.populating_next_right_pointers",
    "description": "__UNSORTED.116_populating_next_right_pointers_in_each_node.populating_next_right_pointers",
    "peekOfCode": "class Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: TreeLinkNode\n        :rtype: nothing\n        \"\"\"\n        if not root:\n            return None\n        root.next = None\n        self.recurse(root)",
    "detail": "__UNSORTED.116_populating_next_right_pointers_in_each_node.populating_next_right_pointers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.117_populating_next_right_pointers_in_each_node_ii.populating_next_right_ii",
    "description": "__UNSORTED.117_populating_next_right_pointers_in_each_node_ii.populating_next_right_ii",
    "peekOfCode": "class Solution(object):\n    def connect(self, root):\n        \"\"\"\n        :type root: TreeLinkNode\n        :rtype: nothing\n        \"\"\"\n        if not root:\n            return\n        root.next = None\n        self.recurse(root)",
    "detail": "__UNSORTED.117_populating_next_right_pointers_in_each_node_ii.populating_next_right_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.118_pascal_triangle.pascal_triangle",
    "description": "__UNSORTED.118_pascal_triangle.pascal_triangle",
    "peekOfCode": "class Solution:\n    # @param {integer} numRows\n    # @return {integer[][]}\n    def generate(self, numRows):\n        rows = []\n        for i in range(numRows):\n            row = [1]\n            for j in range(i / 2):\n                row.append(rows[-1][j] + rows[-1][j + 1])\n            if i and i % 2:",
    "detail": "__UNSORTED.118_pascal_triangle.pascal_triangle",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.119_pascal_triangle_ii.pascal_triangle_ii",
    "description": "__UNSORTED.119_pascal_triangle_ii.pascal_triangle_ii",
    "peekOfCode": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        if rowIndex == 0:\n            return [1]\n        row = [1, 1]\n        if rowIndex == 1:",
    "detail": "__UNSORTED.119_pascal_triangle_ii.pascal_triangle_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.120_triangle.triangle",
    "description": "__UNSORTED.120_triangle.triangle",
    "peekOfCode": "class Solution:\n    # @param triangle, a list of lists of integers\n    # @return an integer\n    def minimumTotal(self, triangle):\n        self.memo = {}\n        def get_min(row, col):\n            if (row, col) in self.memo:\n                return self.memo[(row, col)]\n            if row == len(triangle) - 1:\n                return triangle[row][col]",
    "detail": "__UNSORTED.120_triangle.triangle",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.121_best_time_to_buy_and_sell.best_time_to_buy_and_sell",
    "description": "__UNSORTED.121_best_time_to_buy_and_sell.best_time_to_buy_and_sell",
    "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        low = high = current = prices[0]\n        profit = 0",
    "detail": "__UNSORTED.121_best_time_to_buy_and_sell.best_time_to_buy_and_sell",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.122_best_time_to_buy_adn_sell_ii.best_time_to_buy_and_sell_ii",
    "description": "__UNSORTED.122_best_time_to_buy_adn_sell_ii.best_time_to_buy_and_sell_ii",
    "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        current = prices[0]\n        profit = 0",
    "detail": "__UNSORTED.122_best_time_to_buy_adn_sell_ii.best_time_to_buy_and_sell_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.124_binary_tree_max_path_sum.binary_tree_max_path_sum",
    "description": "__UNSORTED.124_binary_tree_max_path_sum.binary_tree_max_path_sum",
    "peekOfCode": "class Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        longest, maxlen = self.recurse(root)\n        return maxlen\n    def recurse(self, node):\n        if not node:",
    "detail": "__UNSORTED.124_binary_tree_max_path_sum.binary_tree_max_path_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.125_valid_palindrome.valid_palindrome",
    "description": "__UNSORTED.125_valid_palindrome.valid_palindrome",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {boolean}\n    def isPalindrome(self, s):\n        s = \"\".join([c.lower() for c in s if c in string.letters + string.digits])\n        if not s:\n            return True\n        l = len(s)\n        for i in range(l / 2):\n            if s[i] != s[l - i - 1]:",
    "detail": "__UNSORTED.125_valid_palindrome.valid_palindrome",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.126_word_ladder_ii.word_ladder_ii_TLE",
    "description": "__UNSORTED.126_word_ladder_ii.word_ladder_ii_TLE",
    "peekOfCode": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: Set[str]\n        :rtype: int\n        \"\"\"\n        def diff(word1, word2):\n            diff = 0",
    "detail": "__UNSORTED.126_word_ladder_ii.word_ladder_ii_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.127_word_ladder.word_ladder",
    "description": "__UNSORTED.127_word_ladder.word_ladder",
    "peekOfCode": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: Set[str]\n        :rtype: int\n        \"\"\"\n        def diff(word1, word2):\n            diff = 0",
    "detail": "__UNSORTED.127_word_ladder.word_ladder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.127_word_ladder.word_ladder_TLE",
    "description": "__UNSORTED.127_word_ladder.word_ladder_TLE",
    "peekOfCode": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: Set[str]\n        :rtype: int\n        \"\"\"\n        def diff(word1, word2):\n            diff = 0",
    "detail": "__UNSORTED.127_word_ladder.word_ladder_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.128_longest_consequetive_sequence.longest_consequtive_sequence",
    "description": "__UNSORTED.128_longest_consequetive_sequence.longest_consequtive_sequence",
    "peekOfCode": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        d = defaultdict(list)\n        _max = 1\n        # build bi-directional graph\n        for num in nums:",
    "detail": "__UNSORTED.128_longest_consequetive_sequence.longest_consequtive_sequence",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.129_sum_root_to_leaf.sum_root_to_leaf",
    "description": "__UNSORTED.129_sum_root_to_leaf.sum_root_to_leaf",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def sumNumbers(self, root):\n        if not root:\n            return 0\n        self.sum = 0\n        self.visitNode(root, str(root.val))\n        return self.sum\n    def visitNode(self, node, v):",
    "detail": "__UNSORTED.129_sum_root_to_leaf.sum_root_to_leaf",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.130_surrounded_regions.surrounded_regions",
    "description": "__UNSORTED.130_surrounded_regions.surrounded_regions",
    "peekOfCode": "class Solution:\n    # @param {character[][]} board\n    # @return {void} Do not return anything, modify board in-place instead.\n    def solve(self, board):\n        if not board:\n            return\n        lx = len(board)\n        ly = len(board[0])\n        # first last column and row\n        for x in range(lx):",
    "detail": "__UNSORTED.130_surrounded_regions.surrounded_regions",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.130_surrounded_regions.surrounded_regions_TLE",
    "description": "__UNSORTED.130_surrounded_regions.surrounded_regions_TLE",
    "peekOfCode": "class Solution:\n    # @param {character[][]} board\n    # @return {void} Do not return anything, modify board in-place instead.\n    def solve(self, board):\n        if not board:\n            return\n        lx = len(board)\n        ly = len(board[0])\n        for x in range(lx):\n            for y in range(ly):",
    "detail": "__UNSORTED.130_surrounded_regions.surrounded_regions_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.131_palindrome_partitioning.palindrome_partitioning",
    "description": "__UNSORTED.131_palindrome_partitioning.palindrome_partitioning",
    "peekOfCode": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        if len(s) == 0:\n            return [[]]\n        if len(s) == 1:\n            return [[s]]",
    "detail": "__UNSORTED.131_palindrome_partitioning.palindrome_partitioning",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii",
    "description": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii",
    "peekOfCode": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s == s[::-1]:\n            return 0\n        if len(s) == 1:\n            return 0",
    "detail": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii_TLE",
    "description": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii_TLE",
    "peekOfCode": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if s==s[::-1]:return 0\n        if len(s)==1: return 0\n        d = set()\n        for i in range(0,len(s)):",
    "detail": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_ii_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_N2",
    "description": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_N2",
    "peekOfCode": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        odddict = {}\n        evendict = {}\n        # map from (i,j) -> whether s[i:j] is palindrome\n        for i in range(len(s)):",
    "detail": "__UNSORTED.132_palindrome_partitioning_ii.palindrome_partitioning_N2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.133_clone_graph.clone_graph",
    "description": "__UNSORTED.133_clone_graph.clone_graph",
    "peekOfCode": "class Solution:\n    # @param node, a undirected graph node\n    # @return a undirected graph node\n    def cloneGraph(self, node):\n        self.visited = {}\n        newnode = self.traverse(node)\n        return newnode\n    def traverse(self, node):\n        if not node:\n            return None",
    "detail": "__UNSORTED.133_clone_graph.clone_graph",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.134_gas_station.gas_station",
    "description": "__UNSORTED.134_gas_station.gas_station",
    "peekOfCode": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        diffs = [gas[i] - cost[i] for i in range(len(gas))]\n        least = 0\n        min_index = 0",
    "detail": "__UNSORTED.134_gas_station.gas_station",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.135_candies.candy",
    "description": "__UNSORTED.135_candies.candy",
    "peekOfCode": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        if not ratings:\n        \treturn 0\n        intervals = []\n        current = 0",
    "detail": "__UNSORTED.135_candies.candy",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.135_candies.candy_graph",
    "description": "__UNSORTED.135_candies.candy_graph",
    "peekOfCode": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        edges = defaultdict(list)\n        pointed_at = [0] * len(ratings)\n        candies = [1] * len(ratings)\n        for i in range(len(ratings) - 1):",
    "detail": "__UNSORTED.135_candies.candy_graph",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.136_single_number.single_number",
    "description": "__UNSORTED.136_single_number.single_number",
    "peekOfCode": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        n = 0\n        for num in nums:\n            n = n ^ num\n        return n",
    "detail": "__UNSORTED.136_single_number.single_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.137_single_number_ii.single_number_ii",
    "description": "__UNSORTED.137_single_number_ii.single_number_ii",
    "peekOfCode": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        result = 0\n        negatives = 0\n        for i in range(32):\n            mask = 1 << i",
    "detail": "__UNSORTED.137_single_number_ii.single_number_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.137_single_number_ii.single_numbe_ii",
    "description": "__UNSORTED.137_single_number_ii.single_numbe_ii",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def singleNumber(self, nums):\n        bins = []\n        maxlen = 0\n        negatives = 0\n        for num in nums:\n            if num < 0:\n                negatives += 1",
    "detail": "__UNSORTED.137_single_number_ii.single_numbe_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.138_copy_list_with_random_pointer.copy_node_list_random",
    "description": "__UNSORTED.138_copy_list_with_random_pointer.copy_node_list_random",
    "peekOfCode": "class Solution(object):\n    def copyRandomList(self, head):\n        \"\"\"\n        :type head: RandomListNode\n        :rtype: RandomListNode\n        \"\"\"\n        if not head:\n            return None\n        p = head\n        np = RandomListNode(head.label)",
    "detail": "__UNSORTED.138_copy_list_with_random_pointer.copy_node_list_random",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.139_word_break.word_break",
    "description": "__UNSORTED.139_word_break.word_break",
    "peekOfCode": "class Solution:\n    # @param s, a string\n    # @param wordDict, a set<string>\n    # @return a boolean\n    def wordBreak(self, s, wordDict):\n        self.tree = {}\n        self.memo = {}\n        for word in wordDict:\n            self.buildNode(word, self.tree)\n        return self.traverse(s)",
    "detail": "__UNSORTED.139_word_break.word_break",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.140_word_break_ii.word_break_ii",
    "description": "__UNSORTED.140_word_break_ii.word_break_ii",
    "peekOfCode": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        self.tree = {}\n        self.memo = {}\n        for word in wordDict:\n            self.buildNode(word, self.tree)\n        self.splits = {}\n        self.traverse(s, 0)\n        return self.gen(s, len(s))\n    def buildNode(self, word, tree):",
    "detail": "__UNSORTED.140_word_break_ii.word_break_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.140_word_break_ii.word_break_ii_TLE",
    "description": "__UNSORTED.140_word_break_ii.word_break_ii_TLE",
    "peekOfCode": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: Set[str]\n        :rtype: List[str]\n        \"\"\"\n        if not wordDict:\n            return False\n        self.memo = {}",
    "detail": "__UNSORTED.140_word_break_ii.word_break_ii_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.141_linked_list_cycle.linked_list_cycle",
    "description": "__UNSORTED.141_linked_list_cycle.linked_list_cycle",
    "peekOfCode": "class Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        if not head.next:\n            return False",
    "detail": "__UNSORTED.141_linked_list_cycle.linked_list_cycle",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.142_linked_list_cycle_ii.linked_list_cycle_ii",
    "description": "__UNSORTED.142_linked_list_cycle_ii.linked_list_cycle_ii",
    "peekOfCode": "class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        fast = slow = head\n        while fast.next and fast.next.next:",
    "detail": "__UNSORTED.142_linked_list_cycle_ii.linked_list_cycle_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.143_reorder_list.reoder_list",
    "description": "__UNSORTED.143_reorder_list.reoder_list",
    "peekOfCode": "class Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: void Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head:\n            return head\n        stack = []\n        p = head",
    "detail": "__UNSORTED.143_reorder_list.reoder_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.144_binary_tree_preorder_traversal.binary_tree_preorder_loop",
    "description": "__UNSORTED.144_binary_tree_preorder_traversal.binary_tree_preorder_loop",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer[]}\n    def preorderTraversal(self, root):\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()",
    "detail": "__UNSORTED.144_binary_tree_preorder_traversal.binary_tree_preorder_loop",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder",
    "description": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder",
    "peekOfCode": "class Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack = [root]\n        result = []",
    "detail": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder_nondestructive",
    "description": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder_nondestructive",
    "peekOfCode": "class Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        stack1 = [root]\n        stack2 = []",
    "detail": "__UNSORTED.145_binary_tree_postorder_traversal.binary_tree_postorder_nondestructive",
    "documentation": {}
  },
  {
    "label": "LRUCache",
    "kind": 6,
    "importPath": "__UNSORTED.146_lru_cache.lrucache",
    "description": "__UNSORTED.146_lru_cache.lrucache",
    "peekOfCode": "class LRUCache:\n    # @param capacity, an integer\n    def __init__(self, capacity):\n        self.cache = {}\n        self.cap = capacity\n        self.len = 0\n        self.lru = []\n    # @return an integer\n    def get(self, key):\n        val = self.cache.get(key, -1)",
    "detail": "__UNSORTED.146_lru_cache.lrucache",
    "documentation": {}
  },
  {
    "label": "test",
    "kind": 2,
    "importPath": "__UNSORTED.146_lru_cache.lrucache",
    "description": "__UNSORTED.146_lru_cache.lrucache",
    "peekOfCode": "def test():\n    cache = LRUCache(2)\n    print cache.get(1)\n    cache.set(1, 2)\n    print cache.cache, cache.len, cache.lru\n    cache.set(2, 3)\n    print cache.cache, cache.len, cache.lru\n    cache.set(1, 4)\n    print cache.cache, cache.len, cache.lru\n    cache.set(3, 5)",
    "detail": "__UNSORTED.146_lru_cache.lrucache",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\n    def printNode(self):\n        cur = self\n        print cur.val\n        print \"->\"\n        if self.next:\n            self.next.printNode()",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "class Solution:\n    # @param {ListNode} head\n    # @return {ListNode}\n    def insertionSortList(self, head):\n        # first put all nodes in a list\n        nodes = []\n        cur = head\n        while cur:\n            nodes.append(cur)\n            cur = cur.next",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "node0",
    "kind": 5,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "node0 = ListNode(1)\nnode1 = ListNode(1)\nnode0.next = node1\nn = Solution().insertionSortList(node0)\nn.printNode()",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "node1",
    "kind": 5,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "node1 = ListNode(1)\nnode0.next = node1\nn = Solution().insertionSortList(node0)\nn.printNode()",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "node0.next",
    "kind": 5,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "node0.next = node1\nn = Solution().insertionSortList(node0)\nn.printNode()",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "description": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "peekOfCode": "n = Solution().insertionSortList(node0)\nn.printNode()",
    "detail": "__UNSORTED.147_insertion_sort_list.insertion_sort_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "class Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        return self.recurse(head)\n    def recurse(self, node):",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "class Node:\n    pass\nnode1 = Node()\nnode1.val = 3\nnode2 = Node()\nnode2.val = 2\nnode3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node1",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node1 = Node()\nnode1.val = 3\nnode2 = Node()\nnode2.val = 2\nnode3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node1.val",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node1.val = 3\nnode2 = Node()\nnode2.val = 2\nnode3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node2",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node2 = Node()\nnode2.val = 2\nnode3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node2.val",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node2.val = 2\nnode3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node3",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node3 = Node()\nnode3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node3.val",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node3.val = 4\nnode1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node1.next",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node1.next = node2\nnode2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node2.next",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node2.next = node3\nnode3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "node3.next",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "node3.next = None\nn = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "n",
    "kind": 5,
    "importPath": "__UNSORTED.148_sort_list.sort_list",
    "description": "__UNSORTED.148_sort_list.sort_list",
    "peekOfCode": "n = Solution().sortList(node1)\nprint n.val, n.next.val, n.next.next.val",
    "detail": "__UNSORTED.148_sort_list.sort_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.149_max_points_on_a_line.max_points_on_a_line",
    "description": "__UNSORTED.149_max_points_on_a_line.max_points_on_a_line",
    "peekOfCode": "class Solution(object):\n    def maxPoints(self, points):\n        \"\"\"\n        :type points: List[Point]\n        :rtype: int\n        \"\"\"\n        if not points:\n            return 0\n        sets = []\n        _max = 1",
    "detail": "__UNSORTED.149_max_points_on_a_line.max_points_on_a_line",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.150_evaluate_reverse_polish.evaluate_reverse_polish_notation",
    "description": "__UNSORTED.150_evaluate_reverse_polish.evaluate_reverse_polish_notation",
    "peekOfCode": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))",
    "detail": "__UNSORTED.150_evaluate_reverse_polish.evaluate_reverse_polish_notation",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.151_reverse_words_in_a_string.reverse_words_in_string",
    "description": "__UNSORTED.151_reverse_words_in_a_string.reverse_words_in_string",
    "peekOfCode": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        if not s:\n            return \"\"\n        return \" \".join(reversed(s.strip().split()))",
    "detail": "__UNSORTED.151_reverse_words_in_a_string.reverse_words_in_string",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray",
    "description": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray",
    "peekOfCode": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n        self.nums = nums\n        self.max = -sys.maxint",
    "detail": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray_recurse",
    "description": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray_recurse",
    "peekOfCode": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n        self.nums = nums\n        self.max = -sys.maxint",
    "detail": "__UNSORTED.152_maximum_products_subarray.maximum_products_subarray_recurse",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.152_maximum_products_subarray.maxproduct",
    "description": "__UNSORTED.152_maximum_products_subarray.maxproduct",
    "peekOfCode": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        max_product = -sys.maxint\n        min_positive = 1",
    "detail": "__UNSORTED.152_maximum_products_subarray.maxproduct",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.153_find_minimum_rotated_sorted_array.minimum_in_rotated_sorted",
    "description": "__UNSORTED.153_find_minimum_rotated_sorted_array.minimum_in_rotated_sorted",
    "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if nums[0] < nums[-1]:\n            return nums[0]\n        i, j = 0, len(nums) - 1\n        while True:",
    "detail": "__UNSORTED.153_find_minimum_rotated_sorted_array.minimum_in_rotated_sorted",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.154_find_minimum_in_rotated_array_ii.find",
    "description": "__UNSORTED.154_find_minimum_in_rotated_array_ii.find",
    "peekOfCode": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return None\n        if len(nums) == 1:\n            return nums[0]",
    "detail": "__UNSORTED.154_find_minimum_in_rotated_array_ii.find",
    "documentation": {}
  },
  {
    "label": "MinStack",
    "kind": 6,
    "importPath": "__UNSORTED.155_min_stack.min_stack",
    "description": "__UNSORTED.155_min_stack.min_stack",
    "peekOfCode": "class MinStack:\n    # initialize your data structure here.\n    def __init__(self):\n        self.nums = []\n        self.mins = []\n    # @param x, an integer\n    # @return nothing\n    def push(self, x):\n        self.nums.append(x)\n        if self.mins:",
    "detail": "__UNSORTED.155_min_stack.min_stack",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.156_binary_tree_upside_down.binary_tree_upside_down",
    "description": "__UNSORTED.156_binary_tree_upside_down.binary_tree_upside_down",
    "peekOfCode": "class Solution(object):\n    def upsideDownBinaryTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if not root:\n            return root\n        newroot, oldroot = self.recurse(root)\n        return newroot",
    "detail": "__UNSORTED.156_binary_tree_upside_down.binary_tree_upside_down",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.157_read_n_chars.read_N_chars",
    "description": "__UNSORTED.157_read_n_chars.read_N_chars",
    "peekOfCode": "class Solution(object):\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        readcnt = 0\n        while True:\n            buff = [None, None, None, None]",
    "detail": "__UNSORTED.157_read_n_chars.read_N_chars",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.158_read_n_chars_ii.read_N_chars",
    "description": "__UNSORTED.158_read_n_chars_ii.read_N_chars",
    "peekOfCode": "class Solution(object):\n    def __init__(self):\n        self.tmp = []\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Maximum number of characters to read (int)\n        :rtype: The number of characters read (int)\n        \"\"\"\n        idx = 0",
    "detail": "__UNSORTED.158_read_n_chars_ii.read_N_chars",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.159_longest_substring_with_at_most_2_chars.longest_substring",
    "description": "__UNSORTED.159_longest_substring_with_at_most_2_chars.longest_substring",
    "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstringTwoDistinct(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s:\n            return 0\n        c = s[0]\n        maxlen = 0",
    "detail": "__UNSORTED.159_longest_substring_with_at_most_2_chars.longest_substring",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.160_intersection_of_linked_lists.intersection_of_two_linked_lists",
    "description": "__UNSORTED.160_intersection_of_linked_lists.intersection_of_two_linked_lists",
    "peekOfCode": "class Solution:\n    # @param two ListNodes\n    # @return the intersected ListNode\n    def getIntersectionNode(self, headA, headB):\n        def len(node):\n            i = 0\n            while node:\n                i += 1\n                node = node.next\n            return i",
    "detail": "__UNSORTED.160_intersection_of_linked_lists.intersection_of_two_linked_lists",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.161_one_edit_distance.one_edit_distance",
    "description": "__UNSORTED.161_one_edit_distance.one_edit_distance",
    "peekOfCode": "class Solution(object):\n    def isOneEditDistance(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if abs(len(s) - len(t)) > 1:\n            return False\n        if len(s) == len(t):",
    "detail": "__UNSORTED.161_one_edit_distance.one_edit_distance",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.162_peak_element.find_peak_element",
    "description": "__UNSORTED.162_peak_element.find_peak_element",
    "peekOfCode": "class Solution:\n    # @param nums, an integer[]\n    # @return an integer\n    def findPeakElement(self, nums):\n        l = len(nums)\n        left = 0\n        right = l - 1\n        i = 0\n        while True:\n            i = (left + right) / 2",
    "detail": "__UNSORTED.162_peak_element.find_peak_element",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.163_find_missing_ranges.find_missing_ranges",
    "description": "__UNSORTED.163_find_missing_ranges.find_missing_ranges",
    "peekOfCode": "class Solution(object):\n    def findMissingRanges(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: List[str]\n        \"\"\"\n        start = lower\n        ranges = []",
    "detail": "__UNSORTED.163_find_missing_ranges.find_missing_ranges",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.164_maximum_gap.maximum_gap",
    "description": "__UNSORTED.164_maximum_gap.maximum_gap",
    "peekOfCode": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) < 2:\n            return 0\n        _min, _max = min(nums), max(nums)\n        if _min == _max:",
    "detail": "__UNSORTED.164_maximum_gap.maximum_gap",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.165_compare_version_numbers.compare_version_numbers",
    "description": "__UNSORTED.165_compare_version_numbers.compare_version_numbers",
    "peekOfCode": "class Solution:\n    # @param {string} version1\n    # @param {string} version2\n    # @return {integer}\n    def compareVersion(self, version1, version2):\n        v1 = [int(digits) for digits in version1.split(\".\")]\n        v2 = [int(digits) for digits in version2.split(\".\")]\n        l = min(len(v1), len(v2))\n        for i in range(l):\n            if v1[i]!=v2[i]:",
    "detail": "__UNSORTED.165_compare_version_numbers.compare_version_numbers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "description": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "peekOfCode": "class Solution:\n    # @param {integer} numerator\n    # @param {integer} denominator\n    # @return {string}\n    def fractionToDecimal(self, numerator, denominator):    \t\n    \tn = numerator\n    \td = denominator\n    \tif n*d <0:\n    \t\tnegative = True\n    \telse:",
    "detail": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "documentation": {}
  },
  {
    "label": "\t\tret",
    "kind": 5,
    "importPath": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "description": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "peekOfCode": "\t\tret =  str(int_part)\n\telse:\n\t\tret =  str(int_part)+\".\"+after_point\n\tif negative:\n\t\treturn \"-\"+ret\n\telse:\n\t\treturn ret",
    "detail": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "documentation": {}
  },
  {
    "label": "\t\tret",
    "kind": 5,
    "importPath": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "description": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "peekOfCode": "\t\tret =  str(int_part)+\".\"+after_point\n\tif negative:\n\t\treturn \"-\"+ret\n\telse:\n\t\treturn ret",
    "detail": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal_take2",
    "description": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal_take2",
    "peekOfCode": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        if denominator==0:\n            raise Exception(\"Div by Zero\")\n        if numerator==0:",
    "detail": "__UNSORTED.166_fraction_to_recurring_decimal.fraction_to_decimal_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.167_two_sum_ii.two_sum_ii",
    "description": "__UNSORTED.167_two_sum_ii.two_sum_ii",
    "peekOfCode": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        if len(numbers) < 2:\n            return []\n        start = 0",
    "detail": "__UNSORTED.167_two_sum_ii.two_sum_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.168_excel_sheet.excel_sheet_column_title",
    "description": "__UNSORTED.168_excel_sheet.excel_sheet_column_title",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {string}\n    def convertToTitle(self, n):\n        s = \"\"\n        while True:\n            m = n/26\n            k = n%26\n            if k == 0:\n                k = 26",
    "detail": "__UNSORTED.168_excel_sheet.excel_sheet_column_title",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.168_excel_sheet.excel_sheet_column_title_take2",
    "description": "__UNSORTED.168_excel_sheet.excel_sheet_column_title_take2",
    "peekOfCode": "class Solution(object):\n    def convertToTitle(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result = \"\"\n        base = 26\n        digits = 1\n        while n > base:",
    "detail": "__UNSORTED.168_excel_sheet.excel_sheet_column_title_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.169_majority_element.majority_element",
    "description": "__UNSORTED.169_majority_element.majority_element",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def majorityElement(self, nums):\n        counter = Counter()\n        max = 0\n        maxnum = 0\n        for num in nums:\n            counter[num] += 1\n            if counter[num] > max:",
    "detail": "__UNSORTED.169_majority_element.majority_element",
    "documentation": {}
  },
  {
    "label": "TwoSum",
    "kind": 6,
    "importPath": "__UNSORTED.170_two_sum_iii.two_sum_iii",
    "description": "__UNSORTED.170_two_sum_iii.two_sum_iii",
    "peekOfCode": "class TwoSum(object):\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here\n        \"\"\"\n        self.numbers = defaultdict(int)\n    def add(self, number):\n        \"\"\"\n        Add the number to an internal data structure.\n        :rtype: nothing",
    "detail": "__UNSORTED.170_two_sum_iii.two_sum_iii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.171_excel_sheet_column_number.excel_sheet_column_number",
    "description": "__UNSORTED.171_excel_sheet_column_number.excel_sheet_column_number",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def titleToNumber(self, s):\n        i = 0\n        for c in s:\n            i = i * 26 + ord(c) - ord(\"A\") + 1\n        return i",
    "detail": "__UNSORTED.171_excel_sheet_column_number.excel_sheet_column_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.172_factorial_trailing_zeros.factorial_trailing_zeros",
    "description": "__UNSORTED.172_factorial_trailing_zeros.factorial_trailing_zeros",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {integer}\n    def trailingZeroes(self, n):\n        if n <= 0:\n            return 0\n        twos = 0\n        fives = 0\n        n2 = n\n        while n2:",
    "detail": "__UNSORTED.172_factorial_trailing_zeros.factorial_trailing_zeros",
    "documentation": {}
  },
  {
    "label": "BSTIterator",
    "kind": 6,
    "importPath": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator",
    "description": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator",
    "peekOfCode": "class BSTIterator:\n    # @param root, a binary search tree's root node\n    def __init__(self, root):\n        if not root:\n            self.head = self.tail = None\n        else:\n            self.head, self.tail = self.flatten(root)\n    def flatten(self, node):\n        if not node.left:\n            head = node",
    "detail": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator",
    "documentation": {}
  },
  {
    "label": "BSTIterator",
    "kind": 6,
    "importPath": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator_take2",
    "description": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator_take2",
    "peekOfCode": "class BSTIterator(object):\n    def __init__(self, root):\n        \"\"\"\n        :type root: TreeNode\n        \"\"\"\n        if not root:\n            self.stack = []\n            return\n        self.stack = [root]\n        while self.stack[-1].left:",
    "detail": "__UNSORTED.173_binary_tree_iterator.binary_search_tree_iterator_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.174_dungeon_game.dungeon_game",
    "description": "__UNSORTED.174_dungeon_game.dungeon_game",
    "peekOfCode": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not dungeon:\n            return 0\n        N = len(dungeon)\n        M = len(dungeon[0])",
    "detail": "__UNSORTED.174_dungeon_game.dungeon_game",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.179_largest_number.largest_number",
    "description": "__UNSORTED.179_largest_number.largest_number",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {string}\n    def largestNumber(self, nums):\n        def ncmp(s1, s2):\n            if s1 + s2 > s2 + s1:\n                return 1\n            elif s1 + s2 == s2 + s1:\n                return 0\n            else:",
    "detail": "__UNSORTED.179_largest_number.largest_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.179_largest_number.largest_number_cmp",
    "description": "__UNSORTED.179_largest_number.largest_number_cmp",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {string}\n    def largestNumber(self, nums):\n        def _cmp(prefix, n1, n2):\n            if not n1:\n                if not n2:\n                    return 0\n                else:\n                    return _cmp(\"\", prefix, n2)",
    "detail": "__UNSORTED.179_largest_number.largest_number_cmp",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.179_largest_number.largest_number_take1",
    "description": "__UNSORTED.179_largest_number.largest_number_take1",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {string}\n    def largestNumber(self, nums):\n        nums = sorted([str(num) for num in nums])\n        result = \"\"\n        while nums:\n            num = self.pickone(nums, None)\n            result += num\n            nums.remove(num)",
    "detail": "__UNSORTED.179_largest_number.largest_number_take1",
    "documentation": {}
  },
  {
    "label": "solution",
    "kind": 5,
    "importPath": "__UNSORTED.179_largest_number.largest_number_take1",
    "description": "__UNSORTED.179_largest_number.largest_number_take1",
    "peekOfCode": "solution = Solution()\nprint solution.largestNumber([4993,9779,9200])",
    "detail": "__UNSORTED.179_largest_number.largest_number_take1",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.186_reverse_words_in_a_string.reverse",
    "description": "__UNSORTED.186_reverse_words_in_a_string.reverse",
    "peekOfCode": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: a list of 1 length strings (List[str])\n        :rtype: nothing\n        \"\"\"\n        if not s:\n            return\n        start = -1\n        for i, c in enumerate(s):",
    "detail": "__UNSORTED.186_reverse_words_in_a_string.reverse",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.187_repeated_dna.repeated_dna_sequences",
    "description": "__UNSORTED.187_repeated_dna.repeated_dna_sequences",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {string[]}\n    def findRepeatedDnaSequences(self, s):\n        if len(s) <= 10:\n            return []\n        d = defaultdict(int)\n        for i in range(len(s) - 9):\n            d[s[i : i + 10]] += 1\n        return [k for k in d if d[k] > 1]",
    "detail": "__UNSORTED.187_repeated_dna.repeated_dna_sequences",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.188_best_time_to_buy_and_sell_iv.bestime",
    "description": "__UNSORTED.188_best_time_to_buy_and_sell_iv.bestime",
    "peekOfCode": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if not prices:\n            return 0\n        buy = [] # buy[i][k] stands for: for first i prices, maximum profit if transacted k time and last is buy",
    "detail": "__UNSORTED.188_best_time_to_buy_and_sell_iv.bestime",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.189_rotate_array.rotate_array",
    "description": "__UNSORTED.189_rotate_array.rotate_array",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {void} Do not return anything, modify nums in-place instead.\n    def rotate(self, nums, k):\n        k = k % len(nums)\n        nums[:] = nums[-k:] + nums[:-k]",
    "detail": "__UNSORTED.189_rotate_array.rotate_array",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.190_reverse_bits.reverse_bits",
    "description": "__UNSORTED.190_reverse_bits.reverse_bits",
    "peekOfCode": "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        binstr = bin(n)[2:]\n        binstr = \"0\" * (32 - len(binstr)) + binstr\n        result = binstr[::-1]\n        return int(result, base=2)",
    "detail": "__UNSORTED.190_reverse_bits.reverse_bits",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.191_number_of_i_bits.number_of_one_bits",
    "description": "__UNSORTED.191_number_of_i_bits.number_of_one_bits",
    "peekOfCode": "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def hammingWeight(self, n):\n        hamming_weight = 0\n        while n:\n            hamming_weight += n & 1\n            n = n >> 1\n        return hamming_weight",
    "detail": "__UNSORTED.191_number_of_i_bits.number_of_one_bits",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.198_house_robber.house_robber",
    "description": "__UNSORTED.198_house_robber.house_robber",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def rob(self, nums):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        self.memo = {}  # idx -> max robbery\n        def get_max_rob(idx):",
    "detail": "__UNSORTED.198_house_robber.house_robber",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.199_binary_tree_right_view.binary_tree_rightside_view",
    "description": "__UNSORTED.199_binary_tree_right_view.binary_tree_rightside_view",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer[]}\n    def rightSideView(self, root):\n        if not root:\n            return []\n        self.result = {}\n        self.height = 0\n        self.visit(root, 0)\n        vals = []",
    "detail": "__UNSORTED.199_binary_tree_right_view.binary_tree_rightside_view",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.200_islands.number_of_islands",
    "description": "__UNSORTED.200_islands.number_of_islands",
    "peekOfCode": "class Solution:\n    # @param {character[][]} grid\n    # @return {integer}\n    def numIslands(self, grid):\n        if not grid:\n            return 0\n        count = 0\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j]=='1':",
    "detail": "__UNSORTED.200_islands.number_of_islands",
    "documentation": {}
  },
  {
    "label": "g1",
    "kind": 5,
    "importPath": "__UNSORTED.200_islands.number_of_islands",
    "description": "__UNSORTED.200_islands.number_of_islands",
    "peekOfCode": "g1 = [\n[c for c in \"11000\"],\n[c for c in \"11000\"],\n[c for c in \"00100\"],\n[c for c in \"00011\"],\n]\ng2 = [\n[c for c in \"11110\"],\n[c for c in \"11010\"],\n[c for c in \"11001\"],",
    "detail": "__UNSORTED.200_islands.number_of_islands",
    "documentation": {}
  },
  {
    "label": "g2",
    "kind": 5,
    "importPath": "__UNSORTED.200_islands.number_of_islands",
    "description": "__UNSORTED.200_islands.number_of_islands",
    "peekOfCode": "g2 = [\n[c for c in \"11110\"],\n[c for c in \"11010\"],\n[c for c in \"11001\"],\n[c for c in \"00011\"],\n]\nprint Solution().numIslands(g1)\nprint Solution().numIslands(g2)",
    "detail": "__UNSORTED.200_islands.number_of_islands",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.201_bitwise_and_of_number_range.bitwise_and_numbers",
    "description": "__UNSORTED.201_bitwise_and_of_number_range.bitwise_and_numbers",
    "peekOfCode": "class Solution:\n    # @param {integer} m\n    # @param {integer} n\n    # @return {integer}\n    def rangeBitwiseAnd(self, m, n):\n        if m == 0 or n == 0:\n            return 0\n        b1 = bin(m)[2:]\n        b2 = bin(n)[2:]\n        if len(b1) != len(b2):",
    "detail": "__UNSORTED.201_bitwise_and_of_number_range.bitwise_and_numbers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.202_happy_number.happy_number",
    "description": "__UNSORTED.202_happy_number.happy_number",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {boolean}\n    def isHappy(self, n):\n        appeared = set()\n        appeared.add(n)\n        while True:\n            digits = [int(c) for c in str(n)]\n            newval = sum([digit ** 2 for digit in digits])\n            if newval == 1:",
    "detail": "__UNSORTED.202_happy_number.happy_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.203_remove_linked_list_elements.remove_linked_list_elements",
    "description": "__UNSORTED.203_remove_linked_list_elements.remove_linked_list_elements",
    "peekOfCode": "class Solution:\n    # @param {ListNode} head\n    # @param {integer} val\n    # @return {ListNode}\n    def removeElements(self, head, val):\n        if not head:\n            return head\n        while head and head.val == val:\n            head = head.next\n        if head:",
    "detail": "__UNSORTED.203_remove_linked_list_elements.remove_linked_list_elements",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.204_count_primes.count_primes",
    "description": "__UNSORTED.204_count_primes.count_primes",
    "peekOfCode": "class Solution(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 2:\n            return 0\n        seive = [1 for i in range(n)]\n        seive[0] = 0",
    "detail": "__UNSORTED.204_count_primes.count_primes",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.205_isomorphic_strings.isomorphic_strings",
    "description": "__UNSORTED.205_isomorphic_strings.isomorphic_strings",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {boolean}\n    def isIsomorphic(self, s, t):\n        if len(s) != len(t):\n            return False\n        d1 = {}\n        d2 = {}\n        for i, c in enumerate(s):",
    "detail": "__UNSORTED.205_isomorphic_strings.isomorphic_strings",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "description": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"",
    "detail": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "description": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "peekOfCode": "class Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        if not head.next:\n            return head",
    "detail": "__UNSORTED.206_reverse_linked_list.reverse_linked_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.207_course_schedule.course_schedule",
    "description": "__UNSORTED.207_course_schedule.course_schedule",
    "peekOfCode": "class Solution:\n    # @param {integer} numCourses\n    # @param {integer[][]} prerequisites\n    # @return {boolean}\n    def canFinish(self, numCourses, prerequisites):\n        # try to do topological sort, if cannot finish, there is a loop\n        in_edges = {}\n        out_edges = {}\n        nodes = []\n        for i in range(numCourses):",
    "detail": "__UNSORTED.207_course_schedule.course_schedule",
    "documentation": {}
  },
  {
    "label": "TrieNode",
    "kind": 6,
    "importPath": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "description": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "peekOfCode": "class TrieNode:\n    # Initialize your data structure here.\n    def __init__(self):\n        self.children = {}\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    # @param {string} word\n    # @return {void}\n    # Inserts a word into the trie.",
    "detail": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "documentation": {}
  },
  {
    "label": "Trie",
    "kind": 6,
    "importPath": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "description": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "peekOfCode": "class Trie:\n    def __init__(self):\n        self.root = TrieNode()\n    # @param {string} word\n    # @return {void}\n    # Inserts a word into the trie.\n    def insert(self, word):\n        node = self.root\n        for c in word:\n            if c not in node.children:",
    "detail": "__UNSORTED.208_implement_trie.implement_trie_prefix_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.209_minium_size_subarray_sum.minimum_size_subarray_sum",
    "description": "__UNSORTED.209_minium_size_subarray_sum.minimum_size_subarray_sum",
    "peekOfCode": "class Solution(object):\n    def minSubArrayLen(self, s, nums):\n        \"\"\"\n        :type s: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # sliding window\n        left = 0\n        _min = sys.maxint",
    "detail": "__UNSORTED.209_minium_size_subarray_sum.minimum_size_subarray_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.210_course_schedule_ii.course_schedule_ii",
    "description": "__UNSORTED.210_course_schedule_ii.course_schedule_ii",
    "peekOfCode": "class Solution(object):\n    def findOrder(self, numCourses, prerequisites):\n        \"\"\"\n        :type numCourses: int\n        :type prerequisites: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        # topological sort\n        courses = set(list(range(numCourses)))\n        result = []",
    "detail": "__UNSORTED.210_course_schedule_ii.course_schedule_ii",
    "documentation": {}
  },
  {
    "label": "WordDictionary",
    "kind": 6,
    "importPath": "__UNSORTED.211_add_and_search_word.add_and_search_ds",
    "description": "__UNSORTED.211_add_and_search_word.add_and_search_ds",
    "peekOfCode": "class WordDictionary:\n    # initialize your data structure here.\n    def __init__(self):\n        self.children = {}\n    # @param {string} word\n    # @return {void}\n    # Adds a word into the data structure.\n    def addWord(self, word):\n        node = self\n        for c in word:",
    "detail": "__UNSORTED.211_add_and_search_word.add_and_search_ds",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.212_word_search_ii.wordsearch",
    "description": "__UNSORTED.212_word_search_ii.wordsearch",
    "peekOfCode": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        # build trie\n        self.trie = {}\n        for word in words:",
    "detail": "__UNSORTED.212_word_search_ii.wordsearch",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.213_house_robber_ii.house_robber_ii",
    "description": "__UNSORTED.213_house_robber_ii.house_robber_ii",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer}\n    def rob(self, nums):\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        self.memo = {}  # idx -> max robbery\n        def get_max_rob(idx, droplast=False):",
    "detail": "__UNSORTED.213_house_robber_ii.house_robber_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.215_kth_element_in_array.kth_largest",
    "description": "__UNSORTED.215_kth_element_in_array.kth_largest",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer}\n    def findKthLargest(self, nums, k):\n        import heapq\n        return heapq.nlargest(k, nums)[k - 1]",
    "detail": "__UNSORTED.215_kth_element_in_array.kth_largest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.215_kth_element_in_array.no_cheat",
    "description": "__UNSORTED.215_kth_element_in_array.no_cheat",
    "peekOfCode": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        start = 0\n        end = len(nums) - 1\n        while True:",
    "detail": "__UNSORTED.215_kth_element_in_array.no_cheat",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.216_combination_sum_iii.combination_sum_iii",
    "description": "__UNSORTED.216_combination_sum_iii.combination_sum_iii",
    "peekOfCode": "class Solution(object):\n    def combinationSum3(self, k, n):\n        \"\"\"\n        :type k: int\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.result = []\n        self.recurse(k, n, [], 0)\n        return self.result",
    "detail": "__UNSORTED.216_combination_sum_iii.combination_sum_iii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.217_contains_duplicate.contains_duplicate",
    "description": "__UNSORTED.217_contains_duplicate.contains_duplicate",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {boolean}\n    def containsDuplicate(self, nums):\n        return len(nums) > len(set(nums))",
    "detail": "__UNSORTED.217_contains_duplicate.contains_duplicate",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.218_skyline_problem.skyline",
    "description": "__UNSORTED.218_skyline_problem.skyline",
    "peekOfCode": "class Solution:\n    def insort(self, point):  # used to insert into sorted self.heights\n        for i, height in enumerate(self.heights):\n            if height[0] > point[1]:\n                break\n        self.heights.insert(i, (point[1], point[3]))\n    def remove(self, point):  # used to remove from self.heights\n        for i, height in enumerate(self.heights):\n            if height[1] == point[3]:\n                break",
    "detail": "__UNSORTED.218_skyline_problem.skyline",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.218_skyline_problem.skyline_take2",
    "description": "__UNSORTED.218_skyline_problem.skyline_take2",
    "peekOfCode": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        corners = []\n        for x1, x2, h in buildings:\n            corners.append((x1, 0, h))\n            corners.append((x2, 1, h))",
    "detail": "__UNSORTED.218_skyline_problem.skyline_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.219_contains_duplicate_ii.contains_duplicate_ii",
    "description": "__UNSORTED.219_contains_duplicate_ii.contains_duplicate_ii",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {boolean}\n    def containsNearbyDuplicate(self, nums, k):\n        c = Counter(nums[:k])\n        for val in c.values():\n            if val > 1:\n                return True\n        start = 0",
    "detail": "__UNSORTED.219_contains_duplicate_ii.contains_duplicate_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii",
    "description": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii",
    "peekOfCode": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        window = []\n        def check_distance_t(i):",
    "detail": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii_TLE",
    "description": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii_TLE",
    "peekOfCode": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :type t: int\n        :rtype: bool\n        \"\"\"\n        if k == 0:\n            return False",
    "detail": "__UNSORTED.220_contains_duplicate_iii.contains_duplicate_iii_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.221_maximal_square.maximal_square",
    "description": "__UNSORTED.221_maximal_square.maximal_square",
    "peekOfCode": "class Solution:\n    # @param {character[][]} matrix\n    # @return {integer}\n    def maximalSquare(self, matrix):\n        if not matrix:\n            return 0\n        max_square = 0\n        self.visited = []\n        for line in matrix:\n            row = []",
    "detail": "__UNSORTED.221_maximal_square.maximal_square",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes",
    "description": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {integer}\n    def countNodes(self, root):\n        def getDepth(node):\n            if not node:\n                return 0\n            depth = 1\n            while node.left:\n                depth += 1",
    "detail": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes_take2",
    "description": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes_take2",
    "peekOfCode": "class Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        # First get to the bottom of tree for its depth\n        depth = 0\n        node = root\n        while node:",
    "detail": "__UNSORTED.222_count_complete_tree_nodes.count_complete_tree_nodes_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.223_rectangle_area.rectangle_area",
    "description": "__UNSORTED.223_rectangle_area.rectangle_area",
    "peekOfCode": "class Solution:\n    # @param {integer} A\n    # @param {integer} B\n    # @param {integer} C\n    # @param {integer} D\n    # @param {integer} E\n    # @param {integer} F\n    # @param {integer} G\n    # @param {integer} H\n    # @return {integer}",
    "detail": "__UNSORTED.223_rectangle_area.rectangle_area",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.224_basic_calculator.basic_calculator",
    "description": "__UNSORTED.224_basic_calculator.basic_calculator",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def calculate(self, s):\n        self.s = s\n        self.idx = 0\n        return self.eval()\n    def eval(self):\n        current = 0\n        def getNumber():",
    "detail": "__UNSORTED.224_basic_calculator.basic_calculator",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.224_basic_calculator.cal",
    "description": "__UNSORTED.224_basic_calculator.cal",
    "peekOfCode": "class Solution(object):\n    def get_token(self, s, i):\n        while i < len(s) and s[i] == \" \":\n            i += 1\n        if i >= len(s):\n            return len(s), None\n        if s[i] in \"+-()\":\n            return i + 1, s[i]\n        num = 0\n        while i < len(s) and s[i] in \"0123456789\":",
    "detail": "__UNSORTED.224_basic_calculator.cal",
    "documentation": {}
  },
  {
    "label": "Stack",
    "kind": 6,
    "importPath": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues",
    "description": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues",
    "peekOfCode": "class Stack:\n    # initialize your data structure here.\n    def __init__(self):\n        self.standing = None\n        self.q = deque()\n    # @param x, an integer\n    # @return nothing\n    def push(self, x):\n        if self.standing:\n            self.q.append(self.standing)",
    "detail": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues",
    "documentation": {}
  },
  {
    "label": "Stack",
    "kind": 6,
    "importPath": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues_take2",
    "description": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues_take2",
    "peekOfCode": "class Stack(object):\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.q1 = []\n        self.q2 = []\n    def push(self, x):\n        \"\"\"\n        :type x: int",
    "detail": "__UNSORTED.225_impl_stack_using_queues.stack_using_queues_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.226_invert_binary_tree.invert_binary_tree",
    "description": "__UNSORTED.226_invert_binary_tree.invert_binary_tree",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @return {TreeNode}\n    def invertTree(self, root):\n\tif not root:\n\t\treturn\n\troot.left, root.right = root.right, root.left\n\tself.invertTree(self.left)\n\tself.invertTree(self.right)",
    "detail": "__UNSORTED.226_invert_binary_tree.invert_binary_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii",
    "description": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @return {integer}\n    def listfind(self, l, element):\n        try:\n            idx = l.index(element)\n        except:\n            idx = -1\n        return idx\n    def calculate(self, s):",
    "detail": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii_take2",
    "description": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii_take2",
    "peekOfCode": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        def get_number(i):\n            # return number, the position after number\n            n = 0\n            while i < len(s) and s[i] == \" \":",
    "detail": "__UNSORTED.227_basic_calculator_ii.basic_calculator_ii_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.228_summary_ranges.summary_ranges",
    "description": "__UNSORTED.228_summary_ranges.summary_ranges",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {string[]}\n    def summaryRanges(self, nums):\n        if not nums:\n            return []\n        results = []\n        start = None\n        for i, n in enumerate(nums):\n            if start is None:",
    "detail": "__UNSORTED.228_summary_ranges.summary_ranges",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.229_majority_element_ii.majority_element_ii",
    "description": "__UNSORTED.229_majority_element_ii.majority_element_ii",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def majorityElement(self, nums):\n        top1 = [None, 0]\n        top2 = [None, 0]\n        for num in nums:\n            if top1[0] == num:\n                top1[1] += 1\n            elif top2[0] == num:",
    "detail": "__UNSORTED.229_majority_element_ii.majority_element_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.230_kth_smallest_element.kth",
    "description": "__UNSORTED.230_kth_smallest_element.kth",
    "peekOfCode": "class Solution(object):\n    def kthSmallest(self, root, k):\n        \"\"\"\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        \"\"\"\n        _, val = self._recurse(root, k)\n        return val\n    def _recurse(self, node, k):",
    "detail": "__UNSORTED.230_kth_smallest_element.kth",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.231_power_of_two.power_of_two",
    "description": "__UNSORTED.231_power_of_two.power_of_two",
    "peekOfCode": "class Solution:\n    # @param {integer} n\n    # @return {boolean}\n    def isPowerOfTwo(self, n):\n        if n == 0:\n            return False\n        return \"1\" not in bin(n)[3:]",
    "detail": "__UNSORTED.231_power_of_two.power_of_two",
    "documentation": {}
  },
  {
    "label": "Queue",
    "kind": 6,
    "importPath": "__UNSORTED.232_make_queue_using_stacks.queue_using_stacks",
    "description": "__UNSORTED.232_make_queue_using_stacks.queue_using_stacks",
    "peekOfCode": "class Queue:\n    # initialize your data structure here.\n    def __init__(self):\n        self.q1 = []\n        self.q2 = []\n    # @param x, an integer\n    # @return nothing\n    def push(self, x):\n        self.q1.append(x)\n    # @return nothing",
    "detail": "__UNSORTED.232_make_queue_using_stacks.queue_using_stacks",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.233_number_of_digit_one.number_of_digit_one",
    "description": "__UNSORTED.233_number_of_digit_one.number_of_digit_one",
    "peekOfCode": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 0:\n            return 0\n        def getNum(m):\n            if m == 0:",
    "detail": "__UNSORTED.233_number_of_digit_one.number_of_digit_one",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.234_palindrome_linked_list.panlindrome",
    "description": "__UNSORTED.234_palindrome_linked_list.panlindrome",
    "peekOfCode": "class Solution:\n    # @param {ListNode} head\n    # @return {boolean}\n    def isPalindrome(self, head):\n        s = []\n        while head != None:\n            s.append(head.val)\n            head = head.next\n        return s == list(reversed(s))",
    "detail": "__UNSORTED.234_palindrome_linked_list.panlindrome",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.234_palindrome_linked_list.panlindrome_reverse",
    "description": "__UNSORTED.234_palindrome_linked_list.panlindrome_reverse",
    "peekOfCode": "class Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return True\n        if not head.next:\n            return True",
    "detail": "__UNSORTED.234_palindrome_linked_list.panlindrome_reverse",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.235_lowst_common_ancestor_bst.lowest_common_ancestor_binary_tree",
    "description": "__UNSORTED.235_lowst_common_ancestor_bst.lowest_common_ancestor_binary_tree",
    "peekOfCode": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        self.p = p\n        self.q = q",
    "detail": "__UNSORTED.235_lowst_common_ancestor_bst.lowest_common_ancestor_binary_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor",
    "description": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor",
    "peekOfCode": "class Solution:\n    # @param {TreeNode} root\n    # @param {TreeNode} p\n    # @param {TreeNode} q\n    # @return {TreeNode}\n    def lowestCommonAncestor(self, root, p, q):\n        self.result = None\n        self.pv = p.val\n        self.qv = q.val\n        self.visit(root)",
    "detail": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor_complex",
    "description": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor_complex",
    "peekOfCode": "class Solution(object):\n    def lowestCommonAncestor(self, root, p, q):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if root == p or root == q:\n            return root",
    "detail": "__UNSORTED.236_lowest_common_ancestor.lowest_common_ancestor_complex",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.237_delete_node_in_linked_list.delete_node_in_linked_list",
    "description": "__UNSORTED.237_delete_node_in_linked_list.delete_node_in_linked_list",
    "peekOfCode": "class Solution:\n    # @param {ListNode} node\n    # @return {void} Do not return anything, modify node in-place instead.\n    def deleteNode(self, node):\n        current = node\n        node = node.next\n        while node.next:\n            current.val = node.val\n            current = node\n            node = node.next",
    "detail": "__UNSORTED.237_delete_node_in_linked_list.delete_node_in_linked_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.238_product_array.product_of_array_except_self",
    "description": "__UNSORTED.238_product_array.product_of_array_except_self",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @return {integer[]}\n    def productExceptSelf(self, nums):\n        before = []\n        after = []\n        product = 1\n        for num in nums:\n            before.append(product)\n            product = product * num",
    "detail": "__UNSORTED.238_product_array.product_of_array_except_self",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.238_product_array.product_of_array_except_self_take2",
    "description": "__UNSORTED.238_product_array.product_of_array_except_self_take2",
    "peekOfCode": "class Solution(object):\n    def productExceptSelf(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        # first pass from front to back\n        product = 1\n        for num in nums:",
    "detail": "__UNSORTED.238_product_array.product_of_array_except_self_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.239_sliding_window_maximum.sliding",
    "description": "__UNSORTED.239_sliding_window_maximum.sliding",
    "peekOfCode": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        result = []\n        q = []\n        for i, num in enumerate(nums):",
    "detail": "__UNSORTED.239_sliding_window_maximum.sliding",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.239_sliding_window_maximum.sliding_window_maximum",
    "description": "__UNSORTED.239_sliding_window_maximum.sliding_window_maximum",
    "peekOfCode": "class Solution:\n    # @param {integer[]} nums\n    # @param {integer} k\n    # @return {integer[]}\n    def maxSlidingWindow(self, nums, k):\n        if not nums:\n            return []\n        left = 0\n        right = k\n        maxes = []",
    "detail": "__UNSORTED.239_sliding_window_maximum.sliding_window_maximum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii",
    "description": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii",
    "peekOfCode": "class Solution:\n    # @param {integer[][]} matrix\n    # @param {integer} target\n    # @return {boolean}\n    def searchMatrix(self, matrix, target):\n        if not matrix or not matrix[0]:\n            return False\n        idx = rowlen = len(matrix[0])\n        for row in matrix:\n            row = row[:idx]",
    "detail": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii_take2",
    "description": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii_take2",
    "peekOfCode": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        x = 0\n        y = 0\n        xx = len(matrix) - 1",
    "detail": "__UNSORTED.240_search_2d_matrix.search_2d_matrix_ii_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis",
    "description": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis",
    "peekOfCode": "class Solution:\n    # @param {string} input\n    # @return {integer[]}\n    def diffWaysToCompute(self, input):\n        self.s = \"\".join([c for c in input if c != \" \"])\n        self.items = re.findall(\"\\+|\\-|\\*|[0-9]+\", self.s)\n        l = len(self.items)\n        self.memo = defaultdict(set)\n        self.visit(0, l - 1)\n        return list(self.memo[(0, l - 1)])",
    "detail": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis_take2",
    "description": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis_take2",
    "peekOfCode": "class Solution(object):\n    def diffWaysToCompute(self, input):\n        \"\"\"\n        :type input: str\n        :rtype: List[int]\n        \"\"\"\n        tokens = []\n        num = 0\n        for c in input:\n            if c in \"+-*\":",
    "detail": "__UNSORTED.241_different_ways_to_add_parenthesis.different_ways_to_add_parenthesis_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.242_valid_anagram.valid_anagram",
    "description": "__UNSORTED.242_valid_anagram.valid_anagram",
    "peekOfCode": "class Solution:\n    # @param {string} s\n    # @param {string} t\n    # @return {boolean}\n    def isAnagram(self, s, t):\n        return Counter(s) == Counter(t)",
    "detail": "__UNSORTED.242_valid_anagram.valid_anagram",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.243_shortest_word_distance.shortest",
    "description": "__UNSORTED.243_shortest_word_distance.shortest",
    "peekOfCode": "class Solution(object):\n    def shortestDistance(self, words, word1, word2):\n        \"\"\"\n        :type words: List[str]\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        idx1 = -1\n        idx2 = -1",
    "detail": "__UNSORTED.243_shortest_word_distance.shortest",
    "documentation": {}
  },
  {
    "label": "WordDistance",
    "kind": 6,
    "importPath": "__UNSORTED.244_shortest_word_distance_ii.shortest",
    "description": "__UNSORTED.244_shortest_word_distance_ii.shortest",
    "peekOfCode": "class WordDistance(object):\n    def __init__(self, words):\n        \"\"\"\n        initialize your data structure here.\n        :type words: List[str]\n        \"\"\"\n        self.indice = defaultdict(list)\n        self.memo = {}\n        self.MAXLEN = len(words)\n        for i, word in enumerate(words):",
    "detail": "__UNSORTED.244_shortest_word_distance_ii.shortest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.245_shortest_word_distance_iii.shortest",
    "description": "__UNSORTED.245_shortest_word_distance_iii.shortest",
    "peekOfCode": "class Solution(object):\n    def shortestWordDistance(self, words, word1, word2):\n        \"\"\"\n        :type words: List[str]\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        if word1 != word2:\n            idx1 = -1",
    "detail": "__UNSORTED.245_shortest_word_distance_iii.shortest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.246_strobogrammatic_number.strobo",
    "description": "__UNSORTED.246_strobogrammatic_number.strobo",
    "peekOfCode": "class Solution(object):\n    def isStrobogrammatic(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        pairs = {\"1\": \"1\", \"0\": \"0\", \"8\": \"8\", \"6\": \"9\", \"9\": \"6\"}\n        if len(num) % 2 == 0:\n            half = len(num) / 2\n        else:",
    "detail": "__UNSORTED.246_strobogrammatic_number.strobo",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.247_strobogrammatic_number_ii.strobo",
    "description": "__UNSORTED.247_strobogrammatic_number_ii.strobo",
    "peekOfCode": "class Solution(object):\n    pairs = [(\"0\", \"0\"), (\"1\", \"1\"), (\"8\", \"8\"), (\"6\", \"9\"), (\"9\", \"6\")]\n    def findStrobogrammatic(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        return self.recurse(n, n)\n    def recurse(self, n, N):\n        if n == 0:",
    "detail": "__UNSORTED.247_strobogrammatic_number_ii.strobo",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.248_strobogrammatic_number_iii.strobo",
    "description": "__UNSORTED.248_strobogrammatic_number_iii.strobo",
    "peekOfCode": "class Solution(object):\n    def strobogrammaticInRange(self, low, high):\n        \"\"\"\n        :type low: str\n        :type high: str\n        :rtype: int\n        \"\"\"\n        if int(low)>int(high):return 0\n        h = self.countLessThan(int(high))\n        l = self.countLessThan(int(low))",
    "detail": "__UNSORTED.248_strobogrammatic_number_iii.strobo",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.249_group_shifted_strings.group_shifted_strings",
    "description": "__UNSORTED.249_group_shifted_strings.group_shifted_strings",
    "peekOfCode": "class Solution(object):\n    def groupStrings(self, strings):\n        \"\"\"\n        :type strings: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        groups = []\n        alphabet = string.lowercase\n        for s in strings:\n            if not groups:",
    "detail": "__UNSORTED.249_group_shifted_strings.group_shifted_strings",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.250_count_univalue_subtrees.univalue_subtrees",
    "description": "__UNSORTED.250_count_univalue_subtrees.univalue_subtrees",
    "peekOfCode": "class Solution(object):\n    def countUnivalSubtrees(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        self.count = 0\n        self.isUnival(root)",
    "detail": "__UNSORTED.250_count_univalue_subtrees.univalue_subtrees",
    "documentation": {}
  },
  {
    "label": "Vector2D",
    "kind": 6,
    "importPath": "__UNSORTED.251_flatten_2d_vector.flatten",
    "description": "__UNSORTED.251_flatten_2d_vector.flatten",
    "peekOfCode": "class Vector2D(object):\n    def __init__(self, vec2d):\n        \"\"\"\n        Initialize your data structure here.\n        :type vec2d: List[List[int]]\n        \"\"\"\n        self.vec = vec2d\n        self.end_reached = False\n        if not vec2d:\n            self.end_reached = True",
    "detail": "__UNSORTED.251_flatten_2d_vector.flatten",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.252_meeting_rooms.meeting_rooms",
    "description": "__UNSORTED.252_meeting_rooms.meeting_rooms",
    "peekOfCode": "class Solution(object):\n    def canAttendMeetings(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: bool\n        \"\"\"\n        intervals.sort(key=operator.attrgetter(\"start\"))\n        for i in range(len(intervals) - 1):\n            if intervals[i].end > intervals[i + 1].start:\n                return False",
    "detail": "__UNSORTED.252_meeting_rooms.meeting_rooms",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.253_meeting_room_ii.meeting_room_ii",
    "description": "__UNSORTED.253_meeting_room_ii.meeting_room_ii",
    "peekOfCode": "class Solution(object):\n    def minMeetingRooms(self, intervals):\n        \"\"\"\n        :type intervals: List[Interval]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        pairs = []\n        for interval in intervals:",
    "detail": "__UNSORTED.253_meeting_room_ii.meeting_room_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.254_factor_combinations.factor_combinations",
    "description": "__UNSORTED.254_factor_combinations.factor_combinations",
    "peekOfCode": "class Solution(object):\n    def getFactors(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        self.memo = {}\n        return self.recurse(n)\n    def recurse(self, n):\n        if n in self.memo:",
    "detail": "__UNSORTED.254_factor_combinations.factor_combinations",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.255_verify_preorder_sequence.verify",
    "description": "__UNSORTED.255_verify_preorder_sequence.verify",
    "peekOfCode": "class Solution(object):\n    def verifyPreorder(self, preorder):\n        stack = []\n        lower = -1 << 31\n        for x in preorder:\n            if x < lower:\n                return False\n            while stack and x > stack[-1]:\n                lower = stack.pop()\n            stack.append(x)",
    "detail": "__UNSORTED.255_verify_preorder_sequence.verify",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.255_verify_preorder_sequence.verify_take_2",
    "description": "__UNSORTED.255_verify_preorder_sequence.verify_take_2",
    "peekOfCode": "class Solution(object):\n    def verifyPreorder(self, preorder):\n        \"\"\"\n        :type preorder: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(preorder) < 2:\n            return True\n        roots = (\n            []",
    "detail": "__UNSORTED.255_verify_preorder_sequence.verify_take_2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.255_verify_preorder_sequence.verify_TLE",
    "description": "__UNSORTED.255_verify_preorder_sequence.verify_TLE",
    "peekOfCode": "class Solution(object):\n    def verifyPreorder(self, preorder):\n        \"\"\"\n        :type preorder: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(preorder) < 2:\n            return True\n        root = preorder[0]\n        breakpoint = -1",
    "detail": "__UNSORTED.255_verify_preorder_sequence.verify_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.256_paint_house.paint_house",
    "description": "__UNSORTED.256_paint_house.paint_house",
    "peekOfCode": "class Solution(object):\n    def minCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        self.costs = costs\n        self.memo = {}\n        if not costs:\n            return 0",
    "detail": "__UNSORTED.256_paint_house.paint_house",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.257_binary_tree_paths.binary_tree_paths",
    "description": "__UNSORTED.257_binary_tree_paths.binary_tree_paths",
    "peekOfCode": "class Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        self.paths = []\n        self.visit(root, \"\")\n        return self.paths\n    def visit(self, node, current):",
    "detail": "__UNSORTED.257_binary_tree_paths.binary_tree_paths",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.258_add_digits.add_digits",
    "description": "__UNSORTED.258_add_digits.add_digits",
    "peekOfCode": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        # digital root = n - 9*floor(n-1/9)\n        if num == 0:\n            return 0\n        import math",
    "detail": "__UNSORTED.258_add_digits.add_digits",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.259_threesum_smaller.3sum_smaller",
    "description": "__UNSORTED.259_threesum_smaller.3sum_smaller",
    "peekOfCode": "class Solution(object):\n    def threeSumSmaller(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        if len(nums) < 3:\n            return 0\n        nums.sort()",
    "detail": "__UNSORTED.259_threesum_smaller.3sum_smaller",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.260_single_number_iii.single_number_iii",
    "description": "__UNSORTED.260_single_number_iii.single_number_iii",
    "peekOfCode": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        xor = 0\n        for num in nums:\n            xor = xor ^ num\n        lastbit = xor & (-xor)",
    "detail": "__UNSORTED.260_single_number_iii.single_number_iii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.261_graph_valid_tree.valid_tree",
    "description": "__UNSORTED.261_graph_valid_tree.valid_tree",
    "peekOfCode": "class Solution(object):\n    def validTree(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        if n == 1:\n            return True\n        self.leaders = {}",
    "detail": "__UNSORTED.261_graph_valid_tree.valid_tree",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.263_ugly_number.ugly_number",
    "description": "__UNSORTED.263_ugly_number.ugly_number",
    "peekOfCode": "class Solution(object):\n    def isUgly(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        if num <= 0:\n            return False\n        while num % 5 == 0:\n            num = num / 5",
    "detail": "__UNSORTED.263_ugly_number.ugly_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.264_ugly_number_ii.ugly_number_ii",
    "description": "__UNSORTED.264_ugly_number_ii.ugly_number_ii",
    "peekOfCode": "class Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 1\n        results = [1]\n        i2, i3, i5 = 0, 0, 0",
    "detail": "__UNSORTED.264_ugly_number_ii.ugly_number_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.265_paint_house_ii.paint_house_ii",
    "description": "__UNSORTED.265_paint_house_ii.paint_house_ii",
    "peekOfCode": "class Solution(object):\n    def minCostII(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not costs:\n            return 0\n        self.costs = costs\n        self.memo = {}",
    "detail": "__UNSORTED.265_paint_house_ii.paint_house_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.266_palindrome_permutation.permutation",
    "description": "__UNSORTED.266_palindrome_permutation.permutation",
    "peekOfCode": "class Solution(object):\n    def canPermutePalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        d = defaultdict(int)\n        for c in s:\n            d[c] += 1\n        odd = 0",
    "detail": "__UNSORTED.266_palindrome_permutation.permutation",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.267_palindrome_permutation_ii.permutations",
    "description": "__UNSORTED.267_palindrome_permutation_ii.permutations",
    "peekOfCode": "class Solution(object):\n    def generatePalindromes(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        d = defaultdict(int)\n        for c in s:\n            d[c] += 1\n        oddchar = None",
    "detail": "__UNSORTED.267_palindrome_permutation_ii.permutations",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.268_missing_number.missing_number",
    "description": "__UNSORTED.268_missing_number.missing_number",
    "peekOfCode": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        expected = (len(nums) + 1) * len(nums) / 2\n        return expected - sum(nums)",
    "detail": "__UNSORTED.268_missing_number.missing_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.269_alien_dictionary.dictionary",
    "description": "__UNSORTED.269_alien_dictionary.dictionary",
    "peekOfCode": "class Solution(object):\n    def alienOrder(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: str\n        \"\"\"\n        self.matrix = []\n        for i in range(26):\n            row = []\n            for j in range(26):",
    "detail": "__UNSORTED.269_alien_dictionary.dictionary",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.270_closest_binary_search_tree_value.closest",
    "description": "__UNSORTED.270_closest_binary_search_tree_value.closest",
    "peekOfCode": "class Solution(object):\n    def closestValue(self, root, target):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :rtype: int\n        \"\"\"\n        if not root:\n            return None\n        diff = sys.maxint",
    "detail": "__UNSORTED.270_closest_binary_search_tree_value.closest",
    "documentation": {}
  },
  {
    "label": "Codec",
    "kind": 6,
    "importPath": "__UNSORTED.271_encode_and_decode_strings.encode_and_decode",
    "description": "__UNSORTED.271_encode_and_decode_strings.encode_and_decode",
    "peekOfCode": "class Codec:\n    def encode(self, strs):\n        \"\"\"Encodes a list of strings to a single string.\n        :type strs: List[str]\n        :rtype: str\n        \"\"\"\n        encoded = \"\"\n        for s in strs:\n            encoded += str(len(s)) + \".\" + s\n        return encoded",
    "detail": "__UNSORTED.271_encode_and_decode_strings.encode_and_decode",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.272_closest_binary_search_tree_values.closest",
    "description": "__UNSORTED.272_closest_binary_search_tree_values.closest",
    "peekOfCode": "class Solution(object):\n    def closestKValues(self, root, target, k):\n        \"\"\"\n        :type root: TreeNode\n        :type target: float\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        stack = []\n        node = root",
    "detail": "__UNSORTED.272_closest_binary_search_tree_values.closest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.273_english_words.integer_to_english",
    "description": "__UNSORTED.273_english_words.integer_to_english",
    "peekOfCode": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        self.d = {\n            1000000000: \"Billion\",\n            1000000: \"Million\",\n            1000: \"Thousand\",",
    "detail": "__UNSORTED.273_english_words.integer_to_english",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.274_h_index.h_index",
    "description": "__UNSORTED.274_h_index.h_index",
    "peekOfCode": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        citations = list(reversed(sorted(citations)))\n        for i in range(len(citations)):\n            if citations[i] < (i + 1):\n                return i",
    "detail": "__UNSORTED.274_h_index.h_index",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.275_hindex_ii.h_index_ii",
    "description": "__UNSORTED.275_hindex_ii.h_index_ii",
    "peekOfCode": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        if len(citations) == 0:\n            return 0\n        if citations[0] >= len(citations):\n            return len(citations)",
    "detail": "__UNSORTED.275_hindex_ii.h_index_ii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.275_hindex_ii.h_index_ii_take2",
    "description": "__UNSORTED.275_hindex_ii.h_index_ii_take2",
    "peekOfCode": "class Solution(object):\n    def hIndex(self, citations):\n        \"\"\"\n        :type citations: List[int]\n        :rtype: int\n        \"\"\"\n        if not citations:\n            return 0\n        i = 0\n        j = len(citations) - 1",
    "detail": "__UNSORTED.275_hindex_ii.h_index_ii_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.276_paint_fence.paint",
    "description": "__UNSORTED.276_paint_fence.paint",
    "peekOfCode": "class Solution(object):\n    def numWays(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        self.memo = {}\n        return self.recurse(n, k)\n    def recurse(self, n, k):",
    "detail": "__UNSORTED.276_paint_fence.paint",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.277_find_the_celebrity.celebrity",
    "description": "__UNSORTED.277_find_the_celebrity.celebrity",
    "peekOfCode": "class Solution(object):\n    def findCelebrity(self, n):\n        x = 0\n        for i in xrange(n):\n            if knows(x, i):\n                x = i\n        if any(knows(x, i) for i in xrange(x)):\n            return -1\n        if any(not knows(i, x) for i in xrange(n)):\n            return -1",
    "detail": "__UNSORTED.277_find_the_celebrity.celebrity",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.278_first_bad_version.first_bad_version",
    "description": "__UNSORTED.278_first_bad_version.first_bad_version",
    "peekOfCode": "class Solution(object):\n    def firstBadVersion(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        start = 1\n        end = n\n        while True:\n            if start == end:",
    "detail": "__UNSORTED.278_first_bad_version.first_bad_version",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.279_perfect_square_numbers.perfect_squares",
    "description": "__UNSORTED.279_perfect_square_numbers.perfect_squares",
    "peekOfCode": "class Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        self.list = []\n        self.squares = {}\n        i = 1\n        while i * i <= n:",
    "detail": "__UNSORTED.279_perfect_square_numbers.perfect_squares",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.280_wiggle_sort.sort",
    "description": "__UNSORTED.280_wiggle_sort.sort",
    "peekOfCode": "class Solution(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        for i in range(len(nums) - 1):\n            if i % 2 == 0:\n                if nums[i] > nums[i + 1]:\n                    nums[i], nums[i + 1] = nums[i + 1], nums[i]",
    "detail": "__UNSORTED.280_wiggle_sort.sort",
    "documentation": {}
  },
  {
    "label": "ZigzagIterator",
    "kind": 6,
    "importPath": "__UNSORTED.281_zigzag_iterator.iterator",
    "description": "__UNSORTED.281_zigzag_iterator.iterator",
    "peekOfCode": "class ZigzagIterator(object):\n    def __init__(self, v1, v2):\n        \"\"\"\n        Initialize your data structure here.\n        :type v1: List[int]\n        :type v2: List[int]\n        \"\"\"\n        self.index = 0\n        self.numbers = [v1, v2]\n        self.positions = [0, 0]",
    "detail": "__UNSORTED.281_zigzag_iterator.iterator",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n\tself.num = num\n\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tself.num",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tself.num = num\n\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tself.mul_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tself.add_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):\n\tif (start, end) in self.mul_dict:\n\t\treturn self.mul_dict[(start, end)]\n\tresults = []",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tret",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):\n\tif (start, end) in self.mul_dict:\n\t\treturn self.mul_dict[(start, end)]\n\tresults = []\n\tfor i in range(start, end+1):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tresults = []\n\tfor i in range(start, end+1):\n\t\tif i>start and self.num[start]=='0': continue\n\t\tleft = int(self.num[start:i+1])\n\t\tif i<end:\t\n\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\t\tleft",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\t\tleft = int(self.num[start:i+1])\n\t\tif i<end:\t\n\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))\n\tself.mul_dict[(start, end)]= results\n\treturn results\t\n    def recurse(self, start, end):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\t\t\trights",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))\n\tself.mul_dict[(start, end)]= results\n\treturn results\t\n    def recurse(self, start, end):\n\tif (start, end) in self.add_dict:\n\t\treturn self.add_dict[(start, end)]",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tresults = []\n\tfor i in range(start, end+1):\n\t\tlefts = self.mul_dict[(start, i)]\n\t\tif i<end:\n\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\t\tlefts",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\t\tlefts = self.mul_dict[(start, i)]\n\t\tif i<end:\n\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))\n\t\t\t\t\telse:\n\t\t\t\t\t\tresults.append((left+\"+\"+right, vleft+vright))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\t\t\trights",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))\n\t\t\t\t\telse:\n\t\t\t\t\t\tresults.append((left+\"+\"+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+\"+\"+right, -vleft+vright))\n\t\telse:",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "\tself.add_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "peekOfCode": "\tself.add_dict = results\n\treturn results",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n\tself.num = num\n\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tself.num",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tself.num = num\n\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tself.mul_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tself.mul_dict = {(i,i):[(num[i], int(num[i]))] for i in range(len(num))}\n\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tself.add_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tself.add_dict = {}\n\tfor k in range(len(num)):\n\t\tself.recurse_times(0, k)\n\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tresults = self.recurse(0, len(num)-1)\n\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):\n\tif (start, end) in self.mul_dict:\n\t\treturn self.mul_dict[(start, end)]\n\tresults = []",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tret",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tret = []\n\tfor result in results:\n\t\tif result[1]==target and not result[0].startswith(\"-\"):\n\t\t\tret.append(result[0])\n\treturn ret\t\n    def recurse_times(self, start, end):\n\tif (start, end) in self.mul_dict:\n\t\treturn self.mul_dict[(start, end)]\n\tresults = []\n\tfor i in range(start, end+1):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tresults = []\n\tfor i in range(start, end+1):\n\t\tif i>start and self.num[start]=='0': continue\n\t\tleft = int(self.num[start:i+1])\n\t\tif i<end:\t\n\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tleft",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\t\tleft = int(self.num[start:i+1])\n\t\tif i<end:\t\n\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))\n\tself.mul_dict[(start, end)]= results\n\treturn results\t\n    def recurse(self, start, end):",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\trights",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\t\t\trights = self.recurse_times(i+1, end)\n\t\t\tfor s, val in rights:\n\t\t\t\tresults.append((self.num[start:i+1]+\"*\"+s, val*left))\n\t\telse:\n\t\t\tresults.append((self.num[start:i+1], left))\n\tself.mul_dict[(start, end)]= results\n\treturn results\t\n    def recurse(self, start, end):\n\tif (start, end) in self.add_dict:\n\t\treturn self.add_dict[(start, end)]",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tresults",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tresults = []\n\tfor i in range(start, end+1):\n\t\tlefts = self.mul_dict[(start, i)]\n\t\tif i<end:\n\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\t\tlefts",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\t\tlefts = self.mul_dict[(start, i)]\n\t\tif i<end:\n\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))\n\t\t\t\t\telse:\n\t\t\t\t\t\tresults.append((left+\"+\"+right, vleft+vright))",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\t\t\trights",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\t\t\trights = self.recurse(i+1, end)\n\t\t\tfor left, vleft in lefts:\n\t\t\t\tfor right, vright in rights:\n\t\t\t\t\tif right.startswith(\"-\"):\n\t\t\t\t\t\tresults.append((left+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+right, -vleft+vright))\n\t\t\t\t\telse:\n\t\t\t\t\t\tresults.append((left+\"+\"+right, vleft+vright))\n\t\t\t\t\t\tresults.append((\"-\"+left+\"+\"+right, -vleft+vright))\n\t\telse:",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "\tself.add_dict",
    "kind": 5,
    "importPath": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "description": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "peekOfCode": "\tself.add_dict = results\n\treturn results",
    "detail": "__UNSORTED.282_expression_add_operators.expression_add_operators_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.283_move_zeros.move_zeros",
    "description": "__UNSORTED.283_move_zeros.move_zeros",
    "peekOfCode": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zero = -1\n        for i in range(len(nums)):\n            num = nums[i]\n            if num:",
    "detail": "__UNSORTED.283_move_zeros.move_zeros",
    "documentation": {}
  },
  {
    "label": "PeekingIterator",
    "kind": 6,
    "importPath": "__UNSORTED.284_peeking_iterator.peeking_iterator",
    "description": "__UNSORTED.284_peeking_iterator.peeking_iterator",
    "peekOfCode": "class PeekingIterator(object):\n    def __init__(self, iterator):\n        \"\"\"\n        Initialize your data structure here.\n        :type iterator: Iterator\n        \"\"\"\n        self.it = iterator\n        self.cache = None\n    def peek(self):\n        \"\"\"",
    "detail": "__UNSORTED.284_peeking_iterator.peeking_iterator",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.285_inorder_successor_in_BST.successor",
    "description": "__UNSORTED.285_inorder_successor_in_BST.successor",
    "peekOfCode": "class Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        if p.right:\n            node = p.right\n            while node.left:",
    "detail": "__UNSORTED.285_inorder_successor_in_BST.successor",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.286_walls_and_gates.walls_and_gates",
    "description": "__UNSORTED.286_walls_and_gates.walls_and_gates",
    "peekOfCode": "class Solution(object):\n    def wallsAndGates(self, rooms):\n        \"\"\"\n        :type rooms: List[List[int]]\n        :rtype: void Do not return anything, modify rooms in-place instead.\n        \"\"\"\n        q = []\n        for i in range(len(rooms)):\n            for j in range(len(rooms[0])):\n                if rooms[i][j] == 0:",
    "detail": "__UNSORTED.286_walls_and_gates.walls_and_gates",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.287_finding_duplicate_number.find_the_duplicate_number",
    "description": "__UNSORTED.287_finding_duplicate_number.find_the_duplicate_number",
    "peekOfCode": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        # File: FindDuplicate.py\n        # The \"tortoise and hare\" step.  We start at the end of the array and try\n        # to find an intersection point in the cycle.\n        slow = len(nums) - 1",
    "detail": "__UNSORTED.287_finding_duplicate_number.find_the_duplicate_number",
    "documentation": {}
  },
  {
    "label": "ValidWordAbbr",
    "kind": 6,
    "importPath": "__UNSORTED.288_unique_word_abbrevation.abbr",
    "description": "__UNSORTED.288_unique_word_abbrevation.abbr",
    "peekOfCode": "class ValidWordAbbr(object):\n    def __init__(self, dictionary):\n        \"\"\"\n        initialize your data structure here.\n        :type dictionary: List[str]\n        \"\"\"\n        self.abr = defaultdict(set)\n        for word in dictionary:\n            shortened = self.shorten(word)\n            self.abr[shortened].add(word)",
    "detail": "__UNSORTED.288_unique_word_abbrevation.abbr",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.289_game_of_life.game_of_life",
    "description": "__UNSORTED.289_game_of_life.game_of_life",
    "peekOfCode": "class Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board:\n            return []\n        def getNeighbours(b, x, y):\n            width = len(b[0])",
    "detail": "__UNSORTED.289_game_of_life.game_of_life",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.290_word_pattern.word_pattern",
    "description": "__UNSORTED.290_word_pattern.word_pattern",
    "peekOfCode": "class Solution(object):\n    def wordPattern(self, pattern, str):\n        \"\"\"\n        :type pattern: str\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        words = str.split()\n        if len(words) != len(pattern):\n            return False",
    "detail": "__UNSORTED.290_word_pattern.word_pattern",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.291_word_pattern_ii.pattern",
    "description": "__UNSORTED.291_word_pattern_ii.pattern",
    "peekOfCode": "class Solution(object):\n    def wordPatternMatch(self, pattern, str):\n        \"\"\"\n        :type pattern: str\n        :type str: str\n        :rtype: bool\n        \"\"\"\n        if not pattern:\n            return not str\n        if not str:",
    "detail": "__UNSORTED.291_word_pattern_ii.pattern",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.292_nim_game.nim_naive",
    "description": "__UNSORTED.292_nim_game.nim_naive",
    "peekOfCode": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        self.d = {}\n        if n <= 3:\n            return True\n        else:",
    "detail": "__UNSORTED.292_nim_game.nim_naive",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.292_nim_game.vim",
    "description": "__UNSORTED.292_nim_game.vim",
    "peekOfCode": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n\treturn n%4!=0",
    "detail": "__UNSORTED.292_nim_game.vim",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.293_flip_game.flip",
    "description": "__UNSORTED.293_flip_game.flip",
    "peekOfCode": "class Solution(object):\n    def generatePossibleNextMoves(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        if not s or len(s) < 2:\n            return []\n        results = []\n        for i in range(len(s) - 1):",
    "detail": "__UNSORTED.293_flip_game.flip",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.294_flip_game_ii.flip",
    "description": "__UNSORTED.294_flip_game_ii.flip",
    "peekOfCode": "class Solution(object):\n    def canWin(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        self.wins = set()\n        return self.recurse(s)\n    def recurse(self, s):\n        if s in self.wins:",
    "detail": "__UNSORTED.294_flip_game_ii.flip",
    "documentation": {}
  },
  {
    "label": "MedianFinder",
    "kind": 6,
    "importPath": "__UNSORTED.295_find_median_from_data_stream.median",
    "description": "__UNSORTED.295_find_median_from_data_stream.median",
    "peekOfCode": "class MedianFinder:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.minheap = []\n        self.maxheap = []\n    def addNum(self, num):\n        \"\"\"\n        Adds a num into the data structure.",
    "detail": "__UNSORTED.295_find_median_from_data_stream.median",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.296_best_meeting_point.meetingpoint",
    "description": "__UNSORTED.296_best_meeting_point.meetingpoint",
    "peekOfCode": "class Solution(object):\n    def minTotalDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        rows = []\n        cols = []",
    "detail": "__UNSORTED.296_best_meeting_point.meetingpoint",
    "documentation": {}
  },
  {
    "label": "Codec",
    "kind": 6,
    "importPath": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree",
    "description": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree",
    "peekOfCode": "class Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return \"null\"\n        return (\n            \"[\"",
    "detail": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree",
    "documentation": {}
  },
  {
    "label": "Codec",
    "kind": 6,
    "importPath": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree_MLE",
    "description": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree_MLE",
    "peekOfCode": "class Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        if not root:\n            return json.dumps(None)\n        obj = {\n            \"root\": root.val,",
    "detail": "__UNSORTED.297_serialize_and_deserialize_binary_tree.serialize_and_desialize_binary_tree_MLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.298_binary_tree_longest_sequence.longest",
    "description": "__UNSORTED.298_binary_tree_longest_sequence.longest",
    "peekOfCode": "class Solution(object):\n    def longestConsecutive(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        self._max = 0\n        self.recurse(root, 1, root.val)",
    "detail": "__UNSORTED.298_binary_tree_longest_sequence.longest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.299_bulls_and_cows.bulls_and_cows",
    "description": "__UNSORTED.299_bulls_and_cows.bulls_and_cows",
    "peekOfCode": "class Solution(object):\n    def getHint(self, secret, guess):\n        \"\"\"\n        :type secret: str\n        :type guess: str\n        :rtype: str\n        \"\"\"\n        a = 0\n        b = 0\n        counter1 = Counter()",
    "detail": "__UNSORTED.299_bulls_and_cows.bulls_and_cows",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.300_longest_increasing_subsequence.longest",
    "description": "__UNSORTED.300_longest_increasing_subsequence.longest",
    "peekOfCode": "class Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        frontier = []\n        for num in nums:\n            if not frontier or num > frontier[-1]:\n                frontier.append(num)",
    "detail": "__UNSORTED.300_longest_increasing_subsequence.longest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest",
    "description": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest",
    "peekOfCode": "class Solution(object):\n    def minArea(self, image, x, y):\n        \"\"\"\n        :type image: List[List[str]]\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        if not image:\n            return 0",
    "detail": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest_binary_search",
    "description": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest_binary_search",
    "peekOfCode": "class Solution(object):\n    def minArea(self, image, x, y):\n        \"\"\"\n        :type image: List[List[str]]\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        if not image:\n            return 0",
    "detail": "__UNSORTED.302_smallest_rectangle_enclosing_pixels.smallest_binary_search",
    "documentation": {}
  },
  {
    "label": "NumArray",
    "kind": 6,
    "importPath": "__UNSORTED.303_range_sum_query_imutable.range_sum_query",
    "description": "__UNSORTED.303_range_sum_query_imutable.range_sum_query",
    "peekOfCode": "class NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.nums = nums\n        self.sums = [0]\n        sum = 0\n        for num in self.nums:",
    "detail": "__UNSORTED.303_range_sum_query_imutable.range_sum_query",
    "documentation": {}
  },
  {
    "label": "NumMatrix",
    "kind": 6,
    "importPath": "__UNSORTED.304_range_sum_query_2d.rangesum",
    "description": "__UNSORTED.304_range_sum_query_2d.rangesum",
    "peekOfCode": "class NumMatrix(object):\n    def __init__(self, matrix):\n        \"\"\"\n        initialize your data structure here.\n        :type matrix: List[List[int]]\n        \"\"\"\n        self.matrix = matrix\n        if matrix:\n            row0 = []\n            sum = 0",
    "detail": "__UNSORTED.304_range_sum_query_2d.rangesum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.305_number_of_islands_ii.islands",
    "description": "__UNSORTED.305_number_of_islands_ii.islands",
    "peekOfCode": "class Solution(object):\n    def numIslands2(self, m, n, positions):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        islands = 0\n        islandno = 1",
    "detail": "__UNSORTED.305_number_of_islands_ii.islands",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.306_additive_number.additive",
    "description": "__UNSORTED.306_additive_number.additive",
    "peekOfCode": "class Solution(object):\n    def isAdditiveNumber(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        return self.recurse(num, [])\n    def recurse(self, num, triples):\n        if not num:\n            return len(triples) >= 3",
    "detail": "__UNSORTED.306_additive_number.additive",
    "documentation": {}
  },
  {
    "label": "NumArray",
    "kind": 6,
    "importPath": "__UNSORTED.307_range_sum_query_mutable.range_sum_query",
    "description": "__UNSORTED.307_range_sum_query_mutable.range_sum_query",
    "peekOfCode": "class NumArray(object):\n    def __init__(self, nums):\n        \"\"\"\n        initialize your data structure here.\n        :type nums: List[int]\n        \"\"\"\n        self.nums = [0] * len(nums)\n        self.sums = [0] * (len(nums) + 1)\n        for i, num in enumerate(nums):\n            self.update(i, num)",
    "detail": "__UNSORTED.307_range_sum_query_mutable.range_sum_query",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.309_best_time_to_buy_cooldown.best_time",
    "description": "__UNSORTED.309_best_time_to_buy_cooldown.best_time",
    "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) < 2:\n            return 0\n        buy = [-prices[0]]\n        sell = [0]",
    "detail": "__UNSORTED.309_best_time_to_buy_cooldown.best_time",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.309_best_time_to_buy_cooldown.best_time_TLE",
    "description": "__UNSORTED.309_best_time_to_buy_cooldown.best_time_TLE",
    "peekOfCode": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        self.prices = prices\n        return self.recurse(0, 1, 0)\n    def recurse(self, idx, state, price):\n        if idx >= len(self.prices):",
    "detail": "__UNSORTED.309_best_time_to_buy_cooldown.best_time_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.310_minimum_height_trees.mininum_height_trees",
    "description": "__UNSORTED.310_minimum_height_trees.mininum_height_trees",
    "peekOfCode": "class Solution(object):\n    def findMinHeightTrees(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        if n == 1:\n            return [0]\n        self.aj = {}",
    "detail": "__UNSORTED.310_minimum_height_trees.mininum_height_trees",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.311_sparse_matrix_multiplication.multiply",
    "description": "__UNSORTED.311_sparse_matrix_multiplication.multiply",
    "peekOfCode": "class Solution(object):\n    def multiply(self, A, B):\n        \"\"\"\n        :type A: List[List[int]]\n        :type B: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        if not A or not B:\n            return []\n        ra = len(A)",
    "detail": "__UNSORTED.311_sparse_matrix_multiplication.multiply",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.312_burst_balloons.burst",
    "description": "__UNSORTED.312_burst_balloons.burst",
    "peekOfCode": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n            :type nums: List[int]\n            :rtype: int\n            \"\"\"\n        nums = [1] + nums + [1]  # build the complete array\n        n = len(nums)\n        dp = [[0] * n for _ in xrange(n)]\n        for gap in xrange(2, n):",
    "detail": "__UNSORTED.312_burst_balloons.burst",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.313_super_ugly_number.super_ugly",
    "description": "__UNSORTED.313_super_ugly_number.super_ugly",
    "peekOfCode": "class Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        u = [1]\n        idxs = [0] * len(primes)\n        heap = [(v, i) for (i, v) in enumerate(primes)]",
    "detail": "__UNSORTED.313_super_ugly_number.super_ugly",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.314_binary_tree_vertical_order_traversal.traversal",
    "description": "__UNSORTED.314_binary_tree_vertical_order_traversal.traversal",
    "peekOfCode": "class Solution(object):\n    def verticalOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        self.cols = defaultdict(list)\n        self.recurse(root, 0, 0)",
    "detail": "__UNSORTED.314_binary_tree_vertical_order_traversal.traversal",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers",
    "description": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers",
    "peekOfCode": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        pairs = [(num, i) for i, num in enumerate(nums)]\n        s = []\n        d = {}\n        for pair in pairs:",
    "detail": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers_TLE",
    "description": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers_TLE",
    "peekOfCode": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        pairs = [(i, num) for i, num in enumerate(nums)]\n        s = []\n        d = {}\n        for pair in pairs:",
    "detail": "__UNSORTED.315_count_of_smaller_numbers.count_of_smaller_numbers_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters",
    "description": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters",
    "peekOfCode": "class Solution(object):\n    def removeDuplicateLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        all = set(s)\n        chrs = sorted(list(all))\n        for chr in chrs:\n            idx = s.index(chr)",
    "detail": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters_TLE",
    "description": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters_TLE",
    "peekOfCode": "class Solution(object):\n    def removeDuplicateLetters(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        self.counter = Counter()\n        chrs = set()\n        for c in s:\n            chrs.add(c)",
    "detail": "__UNSORTED.316_remove_duplicate_letters.remove_duplicate_letters_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.317_shortest_distance_from_all_buildings.shortest_distance",
    "description": "__UNSORTED.317_shortest_distance_from_all_buildings.shortest_distance",
    "peekOfCode": "class Solution(object):\n    def shortestDistance(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid:\n            return 0\n        # find the houses\n        houses = []",
    "detail": "__UNSORTED.317_shortest_distance_from_all_buildings.shortest_distance",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.318_maximum_product_of_word_lengths.maximum_product_of_word_lengths",
    "description": "__UNSORTED.318_maximum_product_of_word_lengths.maximum_product_of_word_lengths",
    "peekOfCode": "class Solution(object):\n    def maxProduct(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: int\n        \"\"\"\n        maskLen = {\n            self.getMask(word): len(word)\n            for word in sorted(words, key=lambda w: len(w))\n        }",
    "detail": "__UNSORTED.318_maximum_product_of_word_lengths.maximum_product_of_word_lengths",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.319_bulb_switcher.bulb_switcher",
    "description": "__UNSORTED.319_bulb_switcher.bulb_switcher",
    "peekOfCode": "class Solution(object):\n    def bulbSwitch(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        return int(math.sqrt(n))",
    "detail": "__UNSORTED.319_bulb_switcher.bulb_switcher",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.320_generalized_abbreviation.abbreviation",
    "description": "__UNSORTED.320_generalized_abbreviation.abbreviation",
    "peekOfCode": "class Solution(object):\n    def generateAbbreviations(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: List[str]\n        \"\"\"\n        self.memo = {}\n        ret = self.recurse(word)\n        return ret\n    def recurse(self, word):",
    "detail": "__UNSORTED.320_generalized_abbreviation.abbreviation",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.321_create_maximum_number.create_maximum_number",
    "description": "__UNSORTED.321_create_maximum_number.create_maximum_number",
    "peekOfCode": "class Solution(object):\n    def getTable(self, num, k):\n        last = 0\n        result = []\n        while k:\n            _max = max(num[last : len(num) - k + 1])\n            last = last + num[last:].index(_max) + 1\n            result.append(_max)\n            k -= 1\n        return result",
    "detail": "__UNSORTED.321_create_maximum_number.create_maximum_number",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE",
    "description": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE",
    "peekOfCode": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        if k == 0:\n            return []",
    "detail": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE_take2",
    "description": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE_take2",
    "peekOfCode": "class Solution(object):\n    def translate(self, table, length):\n        for c in table:\n            poses = table[c]\n            nexts = []\n            for n in range(length):\n                if not poses:\n                    nexts.append(-1)\n                else:\n                    if n <= poses[0]:",
    "detail": "__UNSORTED.321_create_maximum_number.create_maximum_number_TLE_take2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.322_coin_change.coin_change_TLE",
    "description": "__UNSORTED.322_coin_change.coin_change_TLE",
    "peekOfCode": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        self.d = {}\n        self.coins = sorted(coins)\n        if amount == 0:",
    "detail": "__UNSORTED.322_coin_change.coin_change_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.322_coin_change.coin_change_TLE2",
    "description": "__UNSORTED.322_coin_change.coin_change_TLE2",
    "peekOfCode": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        if amount == 0:\n            return 0\n        self.coins = set(coins)",
    "detail": "__UNSORTED.322_coin_change.coin_change_TLE2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.323_number_of_connected_components.components",
    "description": "__UNSORTED.323_number_of_connected_components.components",
    "peekOfCode": "class Solution(object):\n    def countComponents(self, n, edges):\n        \"\"\"\n        :type n: int\n        :type edges: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        if not edges:",
    "detail": "__UNSORTED.323_number_of_connected_components.components",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE",
    "description": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE",
    "peekOfCode": "class Solution(object):\n    def wiggleSort(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # partition the nums into 2 halves, with left half < right half\n        k1 = 0\n        k2 = len(nums) - 1\n        while True:",
    "detail": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE2",
    "description": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE2",
    "peekOfCode": "class Solution(object):\n    def partition(self, nums, head, tail):\n        # returns a (from, to) interval for the pivot value\n        pivot = nums[tail]\n        i = head\n        while i <= tail:\n            if nums[i] == pivot:\n                i += 1\n            elif nums[i] < pivot:\n                nums[head], nums[i] = nums[i], nums[head]",
    "detail": "__UNSORTED.324_wiggle_sort_ii.wiggle2_TLE2",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.325_maximum_size_subarray.max",
    "description": "__UNSORTED.325_maximum_size_subarray.max",
    "peekOfCode": "class Solution(object):\n    def maxSubArrayLen(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        sums = defaultdict(list)\n        sum = 0\n        result = 0",
    "detail": "__UNSORTED.325_maximum_size_subarray.max",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.326_power_of_three.power_of_three",
    "description": "__UNSORTED.326_power_of_three.power_of_three",
    "peekOfCode": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        if n <= 0:\n            return False\n        import math\n        root = int(math.sqrt(n))",
    "detail": "__UNSORTED.326_power_of_three.power_of_three",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.327_count_of_range_sum.count_of_range_sum",
    "description": "__UNSORTED.327_count_of_range_sum.count_of_range_sum",
    "peekOfCode": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        if not nums: return 0\n        self.nums = nums",
    "detail": "__UNSORTED.327_count_of_range_sum.count_of_range_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.328_odd_even_linked_list.odd_even_linked_list",
    "description": "__UNSORTED.328_odd_even_linked_list.odd_even_linked_list",
    "peekOfCode": "class Solution(object):\n    def oddEvenList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        odd = oddtail = head\n        even = eventail = head.next",
    "detail": "__UNSORTED.328_odd_even_linked_list.odd_even_linked_list",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.329_longest_increasing_path.longest_increasing_path",
    "description": "__UNSORTED.329_longest_increasing_path.longest_increasing_path",
    "peekOfCode": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        self.dp = {}\n        def dp(x, y):\n            if (x, y) not in self.dp:\n                self.dp[(x, y)] = 1 + max(",
    "detail": "__UNSORTED.329_longest_increasing_path.longest_increasing_path",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.330_patching_array.patching",
    "description": "__UNSORTED.330_patching_array.patching",
    "peekOfCode": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        reached = 0",
    "detail": "__UNSORTED.330_patching_array.patching",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.332_reconstruct_itinerary.332_reconstruct_itinerary",
    "description": "__UNSORTED.332_reconstruct_itinerary.332_reconstruct_itinerary",
    "peekOfCode": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        ticketmap = {}\n        self.tickets = tickets\n        for f, t in tickets:\n            if f not in ticketmap:",
    "detail": "__UNSORTED.332_reconstruct_itinerary.332_reconstruct_itinerary",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.333_largest_BST_subtree.largest",
    "description": "__UNSORTED.333_largest_BST_subtree.largest",
    "peekOfCode": "class Solution(object):\n    def largestBSTSubtree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        self.maxsize = 1\n        self.recurse(root)",
    "detail": "__UNSORTED.333_largest_BST_subtree.largest",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.335_self_crossing.self_crossing",
    "description": "__UNSORTED.335_self_crossing.self_crossing",
    "peekOfCode": "class Solution(object):\n    def isSelfCrossing(self, x):\n        \"\"\"\n        :type x: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(x) <= 3:\n            return False\n        i = 2\n        while i < len(x) and x[i] > x[i - 2]:",
    "detail": "__UNSORTED.335_self_crossing.self_crossing",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.336_palindrome_pairs.palindrome_pairs",
    "description": "__UNSORTED.336_palindrome_pairs.palindrome_pairs",
    "peekOfCode": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        self.trie = {}\n        self.buildtrie(words)\n        results = []\n        for j, word in enumerate(words):",
    "detail": "__UNSORTED.336_palindrome_pairs.palindrome_pairs",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.337_house_robber_iii.337_house_robber_iii",
    "description": "__UNSORTED.337_house_robber_iii.337_house_robber_iii",
    "peekOfCode": "class Solution(object):\n    def rob(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        if not hasattr(root, \"max\"):\n            rob1 = self.recurse(root, True)",
    "detail": "__UNSORTED.337_house_robber_iii.337_house_robber_iii",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.338_counting_bits.338_counting_bits",
    "description": "__UNSORTED.338_counting_bits.338_counting_bits",
    "peekOfCode": "class Solution(object):\n    def countBits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: List[int]\n        \"\"\"\n        results = [0, 1]\n        if num < 2:\n            return results[: num + 1]\n        threshold = 2",
    "detail": "__UNSORTED.338_counting_bits.338_counting_bits",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.339_nested_list_weighted_sum.weight_sum",
    "description": "__UNSORTED.339_nested_list_weighted_sum.weight_sum",
    "peekOfCode": "class Solution(object):\n    def depthSum(self, nestedList):\n        \"\"\"\n        :type nestedList: List[NestedInteger]\n        :rtype: int\n        \"\"\"\n        return self.recurse(nestedList, 1)\n    def recurse(self, ll, weight):\n        sum = 0\n        for item in ll:",
    "detail": "__UNSORTED.339_nested_list_weighted_sum.weight_sum",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.340_longest_substr_at_most_k_chars.longest",
    "description": "__UNSORTED.340_longest_substr_at_most_k_chars.longest",
    "peekOfCode": "class Solution(object):\n    def lengthOfLongestSubstringKDistinct(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if k == 0:\n            return 0\n        positions = defaultdict(list)",
    "detail": "__UNSORTED.340_longest_substr_at_most_k_chars.longest",
    "documentation": {}
  },
  {
    "label": "NestedIterator",
    "kind": 6,
    "importPath": "__UNSORTED.341_flatten_nested_list_iterator.flatten",
    "description": "__UNSORTED.341_flatten_nested_list_iterator.flatten",
    "peekOfCode": "class NestedIterator(object):\n    def __init__(self, nestedList):\n        \"\"\"\n        Initialize your data structure here.\n        :type nestedList: List[NestedInteger]\n        \"\"\"\n        self.list = self.flatten(nestedList)\n        self.index = 0\n    def flatten(self, nestedList):\n        result = []",
    "detail": "__UNSORTED.341_flatten_nested_list_iterator.flatten",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.342_power_of_four.power_of_4",
    "description": "__UNSORTED.342_power_of_four.power_of_4",
    "peekOfCode": "class Solution(object):\n    def isPowerOfFour(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        s = bin(num)\n        zeros = 0\n        for i in range(3, len(s)):\n            if s[i] != \"0\":",
    "detail": "__UNSORTED.342_power_of_four.power_of_4",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.343_integer_break.break",
    "description": "__UNSORTED.343_integer_break.break",
    "peekOfCode": "class Solution(object):\n    def integerBreak(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        _max = 0\n        for i in range(2, n + 1):\n            splits = [n / i] * i\n            if n % i:",
    "detail": "__UNSORTED.343_integer_break.break",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.344_reverse_string.reverse",
    "description": "__UNSORTED.344_reverse_string.reverse",
    "peekOfCode": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        rs = []\n        for i in range(len(s) - 1, -1, -1):\n            rs.append(s[i])\n        return \"\".join(rs)",
    "detail": "__UNSORTED.344_reverse_string.reverse",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.345_reverse_vowels.vowels",
    "description": "__UNSORTED.345_reverse_vowels.vowels",
    "peekOfCode": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        vowels = \"aeiou\"\n        poses = []\n        for i, c in enumerate(s):\n            if c.lower() in vowels:",
    "detail": "__UNSORTED.345_reverse_vowels.vowels",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.347_top_k_frequent_elements.topki_pairing_heap",
    "description": "__UNSORTED.347_top_k_frequent_elements.topki_pairing_heap",
    "peekOfCode": "class Solution(object):\n    class PairingHeap(object):\n        def __init__(self, freqency, children, parent, val):\n            self.fre = freqency\n            self.children = children\n            self.parent = parent\n            self.val = val\n        def increment_fre(self):\n            self.fre += 1\n        def __repr__(self):",
    "detail": "__UNSORTED.347_top_k_frequent_elements.topki_pairing_heap",
    "documentation": {}
  },
  {
    "label": "SummaryRanges",
    "kind": 6,
    "importPath": "__UNSORTED.352_data_stream_disjoint_intervals.352",
    "description": "__UNSORTED.352_data_stream_disjoint_intervals.352",
    "peekOfCode": "class SummaryRanges(object):\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.numbers = []\n    def addNum(self, val):\n        \"\"\"\n        :type val: int\n        :rtype: void",
    "detail": "__UNSORTED.352_data_stream_disjoint_intervals.352",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED._ALL_JS.215 Kth Largest Element in an Array",
    "description": "__UNSORTED._ALL_JS.215 Kth Largest Element in an Array",
    "peekOfCode": "class Solution(object):\n    def findKthLargest(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        pivot = random.choice(nums);\n        nums1, nums2 = [], []\n        for num in nums:",
    "detail": "__UNSORTED._ALL_JS.215 Kth Largest Element in an Array",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.100",
    "description": "__UNSORTED.100",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode",
    "detail": "__UNSORTED.100",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.100",
    "description": "__UNSORTED.100",
    "peekOfCode": "class Solution:\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        if not p or not q:\n            return p == q\n        if p.val != q.val:",
    "detail": "__UNSORTED.100",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.102",
    "description": "__UNSORTED.102",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        queue = deque([(root, 0)])",
    "detail": "__UNSORTED.102",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.102",
    "description": "__UNSORTED.102",
    "peekOfCode": "class Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        queue = deque([(root, 0)])\n        result = []\n        while queue:\n            node, level = queue.popleft()\n            if len(result) - 1 < level:\n                result.append([])",
    "detail": "__UNSORTED.102",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.102",
    "description": "__UNSORTED.102",
    "peekOfCode": "class Solution:\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        result = []\n        this_level = [root]",
    "detail": "__UNSORTED.102",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.103",
    "description": "__UNSORTED.103",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nfrom collections import deque\nfrom typing import List\n\"\"\"\nTime: O(N)\nSpace: O(W), W refers to the width of tree",
    "detail": "__UNSORTED.103",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.103",
    "description": "__UNSORTED.103",
    "peekOfCode": "class Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        result, queue = [], deque([(root, 1)])\n        while queue:\n            node, level = queue.popleft()\n            if len(result) < level:\n                result.append([])\n            if level % 2 == 1:",
    "detail": "__UNSORTED.103",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.103",
    "description": "__UNSORTED.103",
    "peekOfCode": "class Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        result = []\n        def dfs(result, level, node):\n            if level > len(result):\n                result.append([])\n            if level % 2 == 1:\n                result[level - 1].append(node.val)",
    "detail": "__UNSORTED.103",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.104",
    "description": "__UNSORTED.104",
    "peekOfCode": "class Solution:\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
    "detail": "__UNSORTED.104",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.105",
    "description": "__UNSORTED.105",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n# time: O(nlogn)\n# space: O(n)\nclass Solution:\n    def buildTree(self, preorder, inorder):\n        \"\"\"",
    "detail": "__UNSORTED.105",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.105",
    "description": "__UNSORTED.105",
    "peekOfCode": "class Solution:\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        inorderDict = {num: i for i, num in enumerate(inorder)}\n        pre = iter(preorder)\n        def helper(start, end):",
    "detail": "__UNSORTED.105",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.106",
    "description": "__UNSORTED.106",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]",
    "detail": "__UNSORTED.106",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.106",
    "description": "__UNSORTED.106",
    "peekOfCode": "class Solution:\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        inorderDict = {num: i for i, num in enumerate(inorder)}\n        def helper(start, end):\n            if start > end:",
    "detail": "__UNSORTED.106",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.107",
    "description": "__UNSORTED.107",
    "peekOfCode": "class Solution:\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        if not root:\n            return []\n        queue, res = deque([(root, 1)]), []\n        while queue:",
    "detail": "__UNSORTED.107",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.108",
    "description": "__UNSORTED.108",
    "peekOfCode": "class Solution:\n    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:\n        return self.dfs(0, len(nums) - 1, nums)\n    def dfs(self, low, high, nums):\n        if low > high:\n            return None\n        m = low + (high - low) // 2\n        root = TreeNode(nums[m])\n        root.left = self.dfs(low, m - 1, nums)\n        root.right = self.dfs(m + 1, high, nums)",
    "detail": "__UNSORTED.108",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.109",
    "description": "__UNSORTED.109",
    "peekOfCode": "class Solution:\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: TreeNode\n        \"\"\"\n        return self.dfs(head, None)\n    def dfs(self, head, tail):\n        if head == tail:\n            return None",
    "detail": "__UNSORTED.109",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.110",
    "description": "__UNSORTED.110",
    "peekOfCode": "class Solution:\n    def isBalanced(self, root: TreeNode) -> bool:\n        return self.dfs(root) != -1\n    def dfs(self, node):\n        if not node:\n            return 0\n        left = self.dfs(node.left)\n        right = self.dfs(node.right)\n        if left == -1 or right == -1 or abs(left - right) > 1:\n            return -1",
    "detail": "__UNSORTED.110",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.111",
    "description": "__UNSORTED.111",
    "peekOfCode": "class Solution:\n    def minDepth(self, root: TreeNode) -> int:\n        if not root:\n            return 0\n        if None in [root.left, root.right]:\n            return 1 + max(self.minDepth(root.left), self.minDepth(root.right))\n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))\nfrom collections import deque\nclass Solution:\n    def minDepth(self, root):",
    "detail": "__UNSORTED.111",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.111",
    "description": "__UNSORTED.111",
    "peekOfCode": "class Solution:\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        if not root:\n            return 0\n        queue = deque([(root, 1)])\n        while queue:",
    "detail": "__UNSORTED.111",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.112",
    "description": "__UNSORTED.112",
    "peekOfCode": "class Solution:\n    def hasPathSum(self, root, sum):\n        \"\"\"\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        \"\"\"\n        if not root:\n            return False\n        if not root.left and not root.right and root.val == sum:",
    "detail": "__UNSORTED.112",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.113",
    "description": "__UNSORTED.113",
    "peekOfCode": "class Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:\n        result = []\n        self.dfs(root, sum, [], result)\n        return result\n    def dfs(self, node, sum, path, result):\n        if not node:\n            return\n        if not node.left and not node.right and node.val == sum:\n            result.append(path + [node.val])",
    "detail": "__UNSORTED.113",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.114",
    "description": "__UNSORTED.114",
    "peekOfCode": "class Solution:\n    def flatten(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"\n        while root:\n            if not root.right:\n                root.left, root.right = root.right, root.left\n            elif root.left:",
    "detail": "__UNSORTED.114",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.115",
    "description": "__UNSORTED.115",
    "peekOfCode": "class Solution:\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):",
    "detail": "__UNSORTED.115",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.116",
    "description": "__UNSORTED.116",
    "peekOfCode": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        if not root:",
    "detail": "__UNSORTED.116",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.116",
    "description": "__UNSORTED.116",
    "peekOfCode": "class Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        if not root:\n            return None\n        dummy = root\n        queue = [root]\n        while queue:\n            node = queue.pop()\n            if node.right:\n                if node.next:",
    "detail": "__UNSORTED.116",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.117",
    "description": "__UNSORTED.117",
    "peekOfCode": "class Node:\n    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):\n        self.val = val\n        self.left = left\n        self.right = right\n        self.next = next\n\"\"\"\nclass Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        if not root:",
    "detail": "__UNSORTED.117",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.117",
    "description": "__UNSORTED.117",
    "peekOfCode": "class Solution:\n    def connect(self, root: \"Node\") -> \"Node\":\n        if not root:\n            return None\n        result = curr = root\n        head = root\n        while head:\n            curr = head\n            head = None\n            prev = None",
    "detail": "__UNSORTED.117",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.118",
    "description": "__UNSORTED.118",
    "peekOfCode": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        s0 = [1]\n        result = [s0]\n        for i in range(1, numRows):\n            s = [x + y for x, y in zip([0] + s0, s0 + [0])]",
    "detail": "__UNSORTED.118",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.119",
    "description": "__UNSORTED.119",
    "peekOfCode": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        if rowIndex == 0:\n            return [1]\n        s = [1]\n        for i in range(1, rowIndex + 1):\n            s = [sum(x) for x in zip([0] + s, s + [0])]\n        return s",
    "detail": "__UNSORTED.119",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.120",
    "description": "__UNSORTED.120",
    "peekOfCode": "class Solution:\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        dp = [0] * (len(triangle) + 1)\n        for row in triangle[::-1]:\n            for j in range(len(row)):\n                dp[j] = min(dp[j], dp[j + 1]) + row[j]",
    "detail": "__UNSORTED.120",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.121",
    "description": "__UNSORTED.121",
    "peekOfCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices or len(prices) < 2:\n            return 0\n        ret = 0\n        buy = prices[0]\n        for price in prices[1:]:\n            buy = min(price, buy)\n            ret = max(ret, price - buy)\n        return ret",
    "detail": "__UNSORTED.121",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.122",
    "description": "__UNSORTED.122",
    "peekOfCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        return sum(max(prices[i + 1] - prices[i], 0) for i in range(len(prices) - 1))",
    "detail": "__UNSORTED.122",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.123",
    "description": "__UNSORTED.123",
    "peekOfCode": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        buy1, buy2 = float(\"-inf\"), float(\"-inf\")\n        sell1, sell2 = 0, 0\n        for price in prices:\n            buy1 = max(buy1, -price)\n            sell1 = max(sell1, buy1 + price)\n            buy2 = max(buy2, sell1 - price)\n            sell2 = max(sell2, buy2 + price)\n        return sell2",
    "detail": "__UNSORTED.123",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.124",
    "description": "__UNSORTED.124",
    "peekOfCode": "class Solution:\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        self.res = root.val\n        self.dfs(root)\n        return self.res\n    def dfs(self, node):",
    "detail": "__UNSORTED.124",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.125",
    "description": "__UNSORTED.125",
    "peekOfCode": "class Solution:\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        ss = \"\".join(c.lower() for c in s if c.isalnum())\n        return ss[::-1] == ss",
    "detail": "__UNSORTED.125",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.126",
    "description": "__UNSORTED.126",
    "peekOfCode": "class Solution:\n    def findLadders(\n        self, beginWord: str, endWord: str, wordList: List[str]\n    ) -> List[List[str]]:\n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        q = {beginWord}\n        wordList -= q\n        tree = defaultdict(set)",
    "detail": "__UNSORTED.126",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.127",
    "description": "__UNSORTED.127",
    "peekOfCode": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        wordList = set(wordList)\n        if not wordList or endWord not in wordList:\n            return 0\n        wordList.discard(beginWord)\n        q1, q2 = {beginWord}, {endWord}\n        step = 1\n        while q1 and q2:\n            temp = set()",
    "detail": "__UNSORTED.127",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.128",
    "description": "__UNSORTED.128",
    "peekOfCode": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        length = {}\n        unions = {}\n        nums = set(nums)\n        def union(x, y):\n            root1 = find(x)\n            root2 = find(y)",
    "detail": "__UNSORTED.128",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.128",
    "description": "__UNSORTED.128",
    "peekOfCode": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        nums = set(nums)\n        result = 0\n        for num in nums:\n            if num - 1 not in nums:\n                next = num + 1\n                while next in nums:\n                    next += 1\n                result = max(result, next - num)",
    "detail": "__UNSORTED.128",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.128",
    "description": "__UNSORTED.128",
    "peekOfCode": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums or len(nums) == 0:\n            return 0\n        if len(nums) < 2:\n            return 1\n        nums.sort()\n        result, l = 1, 1\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i - 1]:",
    "detail": "__UNSORTED.128",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.129",
    "description": "__UNSORTED.129",
    "peekOfCode": "class Solution:\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        return self.getSum(root, 0)\n    def getSum(self, node, s):\n        if not node:\n            return 0",
    "detail": "__UNSORTED.129",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.130",
    "description": "__UNSORTED.130",
    "peekOfCode": "class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        if not board or not board[0]:\n            return\n        m, n = len(board), len(board[0])\n        queue = deque()\n        for i in range(m):",
    "detail": "__UNSORTED.130",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.131",
    "description": "__UNSORTED.131",
    "peekOfCode": "class Solution:\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        res = []\n        self.dfs(res, [], s)\n        return res\n    def dfs(self, res, path, s):",
    "detail": "__UNSORTED.131",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.132",
    "description": "__UNSORTED.132",
    "peekOfCode": "class Solution:\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        if not s or len(s) == 0:\n            return 0\n        n = len(s)\n        dp = list(range(n))",
    "detail": "__UNSORTED.132",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.133",
    "description": "__UNSORTED.133",
    "peekOfCode": "class Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\nfrom collections import deque\nclass Solution:\n    def cloneGraph(self, node: \"Node\") -> \"Node\":\n        if not node:\n            return None",
    "detail": "__UNSORTED.133",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.133",
    "description": "__UNSORTED.133",
    "peekOfCode": "class Solution:\n    def cloneGraph(self, node: \"Node\") -> \"Node\":\n        if not node:\n            return None\n        visited = {node: Node(node.val)}\n        queue = deque([node])\n        while queue:\n            curr = queue.popleft()\n            for n in curr.neighbors:\n                if n not in visited:",
    "detail": "__UNSORTED.133",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.134",
    "description": "__UNSORTED.134",
    "peekOfCode": "class Solution:\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        start, total, tank = 0, 0, 0\n        for i in range(len(gas)):\n            curr = gas[i] - cost[i]",
    "detail": "__UNSORTED.134",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.135",
    "description": "__UNSORTED.135",
    "peekOfCode": "class Solution:\n    # time: O(n)\n    # space: O(n)\n    # def candy(self, ratings):\n    #     \"\"\"\n    #     :type ratings: List[int]\n    #     :rtype: int\n    #     \"\"\"\n    #     res = [1]*len(ratings)\n    #     for i in range(1, len(ratings)):",
    "detail": "__UNSORTED.135",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.138",
    "description": "__UNSORTED.138",
    "peekOfCode": "class Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\nfrom collections import defaultdict\nclass Solution:\n    def copyRandomList(self, head: \"Node\") -> \"Node\":\n        d = defaultdict(lambda: Node(0, None, None))",
    "detail": "__UNSORTED.138",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.138",
    "description": "__UNSORTED.138",
    "peekOfCode": "class Solution:\n    def copyRandomList(self, head: \"Node\") -> \"Node\":\n        d = defaultdict(lambda: Node(0, None, None))\n        d[None] = None\n        curr = head\n        while curr:\n            d[curr].val = curr.val\n            d[curr].next = d[curr.next]\n            d[curr].random = d[curr.random]\n            curr = curr.next",
    "detail": "__UNSORTED.138",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.139",
    "description": "__UNSORTED.139",
    "peekOfCode": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordDict = set(wordDict)\n        return self.dfs(s, wordDict, {})\n    def dfs(self, s, wordDict, cache):\n        if s in cache:\n            return cache[s]\n        if s in wordDict:\n            return True\n        for i in range(1, len(s)):",
    "detail": "__UNSORTED.139",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.139",
    "description": "__UNSORTED.139",
    "peekOfCode": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        wordDict = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        for j in range(1, len(s) + 1):\n            for i in range(j):\n                word = s[i:j]\n                if word in wordDict and dp[i]:\n                    dp[j] = True",
    "detail": "__UNSORTED.139",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.140",
    "description": "__UNSORTED.140",
    "peekOfCode": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        return self.dfs(s, set(wordDict), dict())\n    def dfs(self, s, wordDict, cache):\n        if s in cache:\n            return cache[s]\n        if len(s) == 0:\n            return [\"\"]\n        result = []\n        for i in range(1, len(s) + 1):",
    "detail": "__UNSORTED.140",
    "documentation": {}
  },
  {
    "label": "ListNode",
    "kind": 6,
    "importPath": "__UNSORTED.141",
    "description": "__UNSORTED.141",
    "peekOfCode": "class ListNode(object):\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"",
    "detail": "__UNSORTED.141",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.141",
    "description": "__UNSORTED.141",
    "peekOfCode": "class Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head:\n            return False\n        fast = slow = head\n        while fast.next and fast.next.next:",
    "detail": "__UNSORTED.141",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.142",
    "description": "__UNSORTED.142",
    "peekOfCode": "class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        slow, fast = head, head.next\n        while fast and fast.next:",
    "detail": "__UNSORTED.142",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.143",
    "description": "__UNSORTED.143",
    "peekOfCode": "class Solution:\n    def reorderList(self, head: ListNode) -> None:\n        \"\"\"\n        Do not return anything, modify head in-place instead.\n        \"\"\"\n        if not head:\n            return\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next",
    "detail": "__UNSORTED.143",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.144",
    "description": "__UNSORTED.144",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]",
    "detail": "__UNSORTED.144",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.144",
    "description": "__UNSORTED.144",
    "peekOfCode": "class Solution:\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root:\n            return (\n                [root.val]\n                + self.preorderTraversal(root.left)",
    "detail": "__UNSORTED.144",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.145",
    "description": "__UNSORTED.145",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]",
    "detail": "__UNSORTED.145",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.145",
    "description": "__UNSORTED.145",
    "peekOfCode": "class Solution:\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if root:\n            return (\n                self.postorderTraversal(root.left)\n                + self.postorderTraversal(root.right)",
    "detail": "__UNSORTED.145",
    "documentation": {}
  },
  {
    "label": "Node",
    "kind": 6,
    "importPath": "__UNSORTED.146",
    "description": "__UNSORTED.146",
    "peekOfCode": "class Node(object):\n    def __init__(self, key, val):\n        self.key = key\n        self.val = val\n        self.next = None\n        self.prev = None\nclass LRUCache(object):\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int",
    "detail": "__UNSORTED.146",
    "documentation": {}
  },
  {
    "label": "LRUCache",
    "kind": 6,
    "importPath": "__UNSORTED.146",
    "description": "__UNSORTED.146",
    "peekOfCode": "class LRUCache(object):\n    def __init__(self, capacity):\n        \"\"\"\n        :type capacity: int\n        \"\"\"\n        self.capacity = capacity\n        self.dict = {}\n        self.head = Node(0, 0)\n        self.tail = Node(0, 0)\n        self.head.next = self.tail",
    "detail": "__UNSORTED.146",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.147",
    "description": "__UNSORTED.147",
    "peekOfCode": "class Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None\n        sortedList = head\n        head = head.next",
    "detail": "__UNSORTED.147",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.148",
    "description": "__UNSORTED.148",
    "peekOfCode": "class Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head or not head.next:\n            return head\n        slow, fast = head, head.next\n        while fast.next and fast.next.next:",
    "detail": "__UNSORTED.148",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.149",
    "description": "__UNSORTED.149",
    "peekOfCode": "class Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        n = len(points)\n        if n <= 2:\n            return n\n        result = 0\n        for i in range(n):\n            curmax = 0\n            overlap = 0\n            d = dict()",
    "detail": "__UNSORTED.149",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.150",
    "description": "__UNSORTED.150",
    "peekOfCode": "class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for token in tokens:\n            if token not in {\"+\", \"-\", \"*\", \"/\"}:\n                stack.append(int(token))\n            else:\n                r, l = stack.pop(), stack.pop()\n                if token == \"+\":\n                    stack.append(l + r)",
    "detail": "__UNSORTED.150",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.151",
    "description": "__UNSORTED.151",
    "peekOfCode": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        ss = \" \".join(s.split()[::-1])\n        return ss",
    "detail": "__UNSORTED.151",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.152",
    "description": "__UNSORTED.152",
    "peekOfCode": "class Solution:\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        result = big = small = nums[0]\n        for num in nums[1:]:",
    "detail": "__UNSORTED.152",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.153",
    "description": "__UNSORTED.153",
    "peekOfCode": "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        l, r = 0, len(nums) - 1\n        while l < r:",
    "detail": "__UNSORTED.153",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.154",
    "description": "__UNSORTED.154",
    "peekOfCode": "class Solution:\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return -1\n        l, r = 0, len(nums) - 1\n        while l < r:",
    "detail": "__UNSORTED.154",
    "documentation": {}
  },
  {
    "label": "MinStack",
    "kind": 6,
    "importPath": "__UNSORTED.155",
    "description": "__UNSORTED.155",
    "peekOfCode": "class MinStack:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.stack = []\n    def push(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: void",
    "detail": "__UNSORTED.155",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.157",
    "description": "__UNSORTED.157",
    "peekOfCode": "class Solution:\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Number of characters to read (int)\n        :rtype: The number of actual characters read (int)\n        \"\"\"\n        i = 0\n        while i < n:\n            buf4 = [\" \"] * 4",
    "detail": "__UNSORTED.157",
    "documentation": {}
  },
  {
    "label": "file",
    "kind": 5,
    "importPath": "__UNSORTED.157",
    "description": "__UNSORTED.157",
    "peekOfCode": "file = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\nclass Solution:\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])",
    "detail": "__UNSORTED.157",
    "documentation": {}
  },
  {
    "label": "buf4",
    "kind": 5,
    "importPath": "__UNSORTED.157",
    "description": "__UNSORTED.157",
    "peekOfCode": "buf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\nclass Solution:\n    def read(self, buf, n):\n        \"\"\"\n        :type buf: Destination buffer (List[str])\n        :type n: Number of characters to read (int)",
    "detail": "__UNSORTED.157",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.158",
    "description": "__UNSORTED.158",
    "peekOfCode": "class Solution:\n    def __init__(self):\n        self.q = deque()\n    def read(self, buf: List[str], n: int) -> int:\n        i = 0\n        while i < n:\n            while self.q and i < n:\n                buf[i] = self.q.popleft()\n                i += 1\n            else:",
    "detail": "__UNSORTED.158",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.159",
    "description": "__UNSORTED.159",
    "peekOfCode": "class Solution:\n    def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n        d = {}\n        count = 0\n        start, end = 0, 0\n        result = 0\n        while end < len(s):\n            c = s[end]\n            d[c] = d.get(c, 0) + 1\n            if d[c] == 1:",
    "detail": "__UNSORTED.159",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.160",
    "description": "__UNSORTED.160",
    "peekOfCode": "class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not headA or not headB:\n            return None\n        pa, pb = headA, headB\n        while pa != pb:",
    "detail": "__UNSORTED.160",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.161",
    "description": "__UNSORTED.161",
    "peekOfCode": "class Solution:\n    def isOneEditDistance(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        if len(s) > len(t):\n            return self.isOneEditDistance(t, s)\n        m, n = len(s), len(t)",
    "detail": "__UNSORTED.161",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.162",
    "description": "__UNSORTED.162",
    "peekOfCode": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            mid = l + (r - l) // 2\n            high_mid = mid + 1\n            if nums[mid] < nums[high_mid]:\n                l = high_mid\n            else:\n                r = mid",
    "detail": "__UNSORTED.162",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.163",
    "description": "__UNSORTED.163",
    "peekOfCode": "class Solution:\n    def findMissingRanges(self, nums: List[int], lower: int, upper: int) -> List[str]:\n        nums = [lower - 1] + nums + [upper + 1]\n        res = []\n        for i in range(len(nums) - 1):\n            if nums[i + 1] - nums[i] == 2:\n                res.append(str(nums[i] + 1))\n            elif nums[i + 1] - nums[i] > 2:\n                res.append(str(nums[i] + 1) + \"->\" + str(nums[i + 1] - 1))\n        return res",
    "detail": "__UNSORTED.163",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.165",
    "description": "__UNSORTED.165",
    "peekOfCode": "class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        l1 = [int(s) for s in version1.split(\".\")]\n        l2 = [int(s) for s in version2.split(\".\")]\n        len1, len2 = len(l1), len(l2)\n        if len1 > len2:\n            l2 += [0] * (len1 - len2)\n        elif len1 < len2:\n            l1 += [0] * (len2 - len1)\n        return (l1 > l2) - (l1 < l2)",
    "detail": "__UNSORTED.165",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.167",
    "description": "__UNSORTED.167",
    "peekOfCode": "class Solution:\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]",
    "detail": "__UNSORTED.167",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.168",
    "description": "__UNSORTED.168",
    "peekOfCode": "class Solution:\n    def convertToTitle(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        result, start = \"\", ord(\"A\")\n        while n > 0:\n            result, n = chr((n - 1) % 26 + start) + result, (n - 1) // 26\n        return result",
    "detail": "__UNSORTED.168",
    "documentation": {}
  },
  {
    "label": "TwoSum",
    "kind": 6,
    "importPath": "__UNSORTED.170",
    "description": "__UNSORTED.170",
    "peekOfCode": "class TwoSum:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.d = {}\n    def add(self, number: int) -> None:\n        \"\"\"\n        Add the number to an internal data structure..\n        \"\"\"",
    "detail": "__UNSORTED.170",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.171",
    "description": "__UNSORTED.171",
    "peekOfCode": "class Solution:\n    def titleToNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        result, start = 0, ord(\"A\")\n        for c in s:\n            result = result * 26 + (ord(c) - start) + 1\n        return result",
    "detail": "__UNSORTED.171",
    "documentation": {}
  },
  {
    "label": "BSTIterator",
    "kind": 6,
    "importPath": "__UNSORTED.173",
    "description": "__UNSORTED.173",
    "peekOfCode": "class BSTIterator:\n    def __init__(self, root: TreeNode):\n        self.result = []\n        def dfs(root):\n            if not root:\n                return\n            if root.right:\n                dfs(root.right)\n            self.result.append(root.val)\n            if root.left:",
    "detail": "__UNSORTED.173",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.179",
    "description": "__UNSORTED.179",
    "peekOfCode": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        nums = list(map(str, nums))\n        comp = lambda x, y: -1 if x + y > y + x else 1 if x + y < y + x else 0\n        return str(int(\"\".join(sorted(nums, key=cmp_to_key(comp)))))",
    "detail": "__UNSORTED.179",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.186",
    "description": "__UNSORTED.186",
    "peekOfCode": "class Solution(object):\n    def reverseWords(self, str):\n        \"\"\"\n        :type str: List[str]\n        :rtype: void Do not return anything, modify str in-place instead.\n        \"\"\"\n        self.reverse(str, 0, len(str) - 1)\n        start, end = 0, -1\n        for i in range(len(str)):\n            if str[i] == \" \":",
    "detail": "__UNSORTED.186",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.188",
    "description": "__UNSORTED.188",
    "peekOfCode": "class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        if n < 2:\n            return 0\n        if n // 2 <= k:\n            return self.quickSolve(prices)\n        dp = [[0 for _ in range(n + 1)] for _ in range(k + 1)]\n        for i in range(1, k + 1):\n            buy = float(\"-inf\")",
    "detail": "__UNSORTED.188",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.189",
    "description": "__UNSORTED.189",
    "peekOfCode": "class Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        if not nums:\n            return\n        n = len(nums)",
    "detail": "__UNSORTED.189",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.190",
    "description": "__UNSORTED.190",
    "peekOfCode": "class Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        res = 0\n        for i in range(32):\n            res += n & 1\n            n = n >> 1\n            if i != 31:\n                res = res << 1",
    "detail": "__UNSORTED.190",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.191",
    "description": "__UNSORTED.191",
    "peekOfCode": "class Solution(object):\n    def hammingWeight(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        bits = 0\n        mask = 1\n        for i in range(32):\n            if (n & mask) != 0:",
    "detail": "__UNSORTED.191",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.198",
    "description": "__UNSORTED.198",
    "peekOfCode": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        s1, s2 = 0, 0\n        for num in nums:\n            s1, s2 = s2, max(s1 + num, s2)\n        return s2",
    "detail": "__UNSORTED.198",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.199",
    "description": "__UNSORTED.199",
    "peekOfCode": "class Solution:\n    def rightSideView(self, root: TreeNode) -> List[int]:\n        if not root:\n            return []\n        queue = deque([(root, 1)])\n        result = []\n        while queue:\n            node, depth = queue.popleft()\n            if len(result) < depth:\n                result.append(node.val)",
    "detail": "__UNSORTED.199",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.200",
    "description": "__UNSORTED.200",
    "peekOfCode": "class Solution:\n    # updated union find\n    def numIslands(self, grid: List[List[str]]) -> int:\n        def find(x):\n            if UF[x] != x:\n                UF[x] = find(UF[x])\n            return UF[x]\n        def union(x, y):\n            UF[find(x)] = find(y)\n        if not grid or not grid[0]:",
    "detail": "__UNSORTED.200",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.200",
    "description": "__UNSORTED.200",
    "peekOfCode": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        m, n = len(grid), len(grid[0])\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == \"1\":\n                    self.dfs(grid, i, j)\n                    count += 1\n        return count",
    "detail": "__UNSORTED.200",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.203",
    "description": "__UNSORTED.203",
    "peekOfCode": "class Solution(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n < 2:\n            return 0\n        A = [0] * (n + 1)\n        count = 0",
    "detail": "__UNSORTED.203",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.204",
    "description": "__UNSORTED.204",
    "peekOfCode": "class Solution(object):\n    def countPrimes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n <= 2:\n            return 0\n        prime = [True] * n\n        prime[:2] = [False, False]",
    "detail": "__UNSORTED.204",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.205",
    "description": "__UNSORTED.205",
    "peekOfCode": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        def convert(ss):\n            d = {}\n            return [d.setdefault(c, len(d)) for c in ss]\n        return convert(s) == convert(t)",
    "detail": "__UNSORTED.205",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.206",
    "description": "__UNSORTED.206",
    "peekOfCode": "class Solution:\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        prev = None\n        while head:\n            head.next, prev, head = prev, head, head.next\n        return prev",
    "detail": "__UNSORTED.206",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.207",
    "description": "__UNSORTED.207",
    "peekOfCode": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph, visited = {}, {}\n        for i in range(numCourses):\n            graph[i] = set()\n            visited[i] = 0\n        for p in prerequisites:\n            graph[p[1]].add(p[0])\n        for k in graph.keys():\n            if not self.dfs(k, graph, visited):",
    "detail": "__UNSORTED.207",
    "documentation": {}
  },
  {
    "label": "TrieNode",
    "kind": 6,
    "importPath": "__UNSORTED.208",
    "description": "__UNSORTED.208",
    "peekOfCode": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\nclass Trie:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()",
    "detail": "__UNSORTED.208",
    "documentation": {}
  },
  {
    "label": "Trie",
    "kind": 6,
    "importPath": "__UNSORTED.208",
    "description": "__UNSORTED.208",
    "peekOfCode": "class Trie:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n    def insert(self, word: str) -> None:\n        \"\"\"\n        Inserts a word into the trie.\n        \"\"\"",
    "detail": "__UNSORTED.208",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.209",
    "description": "__UNSORTED.209",
    "peekOfCode": "class Solution:\n    def minSubArrayLen(self, s, nums):\n        \"\"\"\n        :type s: int\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        total = l = 0\n        result = len(nums) + 1\n        for r in range(len(nums)):",
    "detail": "__UNSORTED.209",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.210",
    "description": "__UNSORTED.210",
    "peekOfCode": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        graph, visited = {}, {}\n        for c in range(numCourses):\n            graph[c] = set()\n            visited[c] = 0\n        for p in prerequisites:\n            graph[p[1]].add(p[0])\n        result = []\n        for key in graph.keys():",
    "detail": "__UNSORTED.210",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.210",
    "description": "__UNSORTED.210",
    "peekOfCode": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        inDegree, tree = [0] * numCourses, defaultdict(set)\n        for p in prerequisites:\n            inDegree[p[0]] += 1\n            tree[p[1]].add(p[0])\n        queue = deque()\n        for i in range(numCourses):\n            if inDegree[i] == 0:\n                queue.append(i)",
    "detail": "__UNSORTED.210",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.211",
    "description": "__UNSORTED.211",
    "peekOfCode": "class TreeNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\nclass WordDictionary:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TreeNode()",
    "detail": "__UNSORTED.211",
    "documentation": {}
  },
  {
    "label": "WordDictionary",
    "kind": 6,
    "importPath": "__UNSORTED.211",
    "description": "__UNSORTED.211",
    "peekOfCode": "class WordDictionary:\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TreeNode()\n    def addWord(self, word: str) -> None:\n        \"\"\"\n        Adds a word into the data structure.\n        \"\"\"",
    "detail": "__UNSORTED.211",
    "documentation": {}
  },
  {
    "label": "TrieNode",
    "kind": 6,
    "importPath": "__UNSORTED.212",
    "description": "__UNSORTED.212",
    "peekOfCode": "class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_word = False\nclass Trie:\n    def __init__(self):\n        self.node = TrieNode()\n    def add(self, word):\n        node = self.node\n        for c in word:",
    "detail": "__UNSORTED.212",
    "documentation": {}
  },
  {
    "label": "Trie",
    "kind": 6,
    "importPath": "__UNSORTED.212",
    "description": "__UNSORTED.212",
    "peekOfCode": "class Trie:\n    def __init__(self):\n        self.node = TrieNode()\n    def add(self, word):\n        node = self.node\n        for c in word:\n            node = node.children.setdefault(c, TrieNode())\n        node.is_word = True\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:",
    "detail": "__UNSORTED.212",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.212",
    "description": "__UNSORTED.212",
    "peekOfCode": "class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        trie = Trie()\n        for word in words:\n            trie.add(word)\n        result = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.dfs(board, result, trie.node, i, j, \"\")\n        return result",
    "detail": "__UNSORTED.212",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.215",
    "description": "__UNSORTED.215",
    "peekOfCode": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        def quickSelect(low, high, k):\n            i = low\n            for j in range(low, high):\n                if nums[j] <= nums[high]:\n                    nums[i], nums[j] = nums[j], nums[i]\n                    i += 1\n            nums[i], nums[high] = nums[high], nums[i]\n            count = high - i + 1",
    "detail": "__UNSORTED.215",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.215",
    "description": "__UNSORTED.215",
    "peekOfCode": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        q = []\n        for i, n in enumerate(nums):\n            heapq.heappush(q, (-n, i))\n        result = None\n        for _ in range(k):\n            result = -heapq.heappop(q)[0]\n        return result",
    "detail": "__UNSORTED.215",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.216",
    "description": "__UNSORTED.216",
    "peekOfCode": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        result = []\n        self.dfs(list(range(1, 10)), k, n, [], result)\n        return result\n    def dfs(self, arr, k, n, path, result):\n        if k < 0 or n < 0:\n            return\n        if k == 0 and n == 0:\n            result.append(path)",
    "detail": "__UNSORTED.216",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.218",
    "description": "__UNSORTED.218",
    "peekOfCode": "class Solution:\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        rectangles = [[l, -h, r] for l, r, h in buildings] + [\n            [r, h, None] for l, r, h in buildings\n        ]\n        rectangles.sort()",
    "detail": "__UNSORTED.218",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.220",
    "description": "__UNSORTED.220",
    "peekOfCode": "class Solution:\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\n        if t < 0:\n            return False\n        d = {}\n        w = t + 1\n        for i, num in enumerate(nums):\n            key = num // w\n            if key in d:\n                return True",
    "detail": "__UNSORTED.220",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.221",
    "description": "__UNSORTED.221",
    "peekOfCode": "class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        slide = 0\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if matrix[i - 1][j - 1] == \"1\":",
    "detail": "__UNSORTED.221",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.224",
    "description": "__UNSORTED.224",
    "peekOfCode": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        curr, total, sign, i = 0, 0, 1, 0\n        stack = []\n        while i < len(s):\n            if s[i].isdigit():",
    "detail": "__UNSORTED.224",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.226",
    "description": "__UNSORTED.226",
    "peekOfCode": "class Solution:\n    def invertTree(self, root: TreeNode) -> TreeNode:\n        if not root:\n            return root\n        temp = root.right\n        root.right = self.invertTree(root.left)\n        root.left = self.invertTree(temp)\n        return root",
    "detail": "__UNSORTED.226",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.227",
    "description": "__UNSORTED.227",
    "peekOfCode": "class Solution:\n    def calculate(self, s: str) -> int:\n        def compute(num1, num2, op):\n            if op == \"-\":\n                return num2 - num1\n            if op == \"+\":\n                return num1 + num2\n            if op == \"*\":\n                return num1 * num2\n            if op == \"/\":",
    "detail": "__UNSORTED.227",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.229",
    "description": "__UNSORTED.229",
    "peekOfCode": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        candidate1, candidate2 = 0, 1\n        count1, count2 = 0, 0\n        for num in nums:\n            if candidate1 == num:\n                count1 += 1\n            elif candidate2 == num:\n                count2 += 1\n            elif count1 == 0:",
    "detail": "__UNSORTED.229",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.230",
    "description": "__UNSORTED.230",
    "peekOfCode": "class Solution:\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\n        result = []\n        def inorder(node):\n            if not node:\n                return\n            inorder(node.left)\n            result.append(node.val)\n            inorder(node.right)\n        inorder(root)",
    "detail": "__UNSORTED.230",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.234",
    "description": "__UNSORTED.234",
    "peekOfCode": "class Solution:\n    def isPalindrome(self, head: ListNode) -> bool:\n        rev = None\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            slow.next, rev, slow = rev, slow, slow.next\n        if fast:\n            slow = slow.next\n        while rev and slow and rev.val == slow.val:",
    "detail": "__UNSORTED.234",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.235",
    "description": "__UNSORTED.235",
    "peekOfCode": "class Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -> \"TreeNode\":\n        if p.val < root.val > q.val:\n            return self.lowestCommonAncestor(root.left, p, q)\n        if p.val > root.val < q.val:\n            return self.lowestCommonAncestor(root.right, p, q)\n        return root\n# class Solution:",
    "detail": "__UNSORTED.235",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.236",
    "description": "__UNSORTED.236",
    "peekOfCode": "class Solution:\n    def lowestCommonAncestor(\n        self, root: \"TreeNode\", p: \"TreeNode\", q: \"TreeNode\"\n    ) -> \"TreeNode\":\n        if root in [None, p, q]:\n            return root\n        left = self.lowestCommonAncestor(root.left, p, q)\n        right = self.lowestCommonAncestor(root.right, p, q)\n        return root if left and right else left or right",
    "detail": "__UNSORTED.236",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.238",
    "description": "__UNSORTED.238",
    "peekOfCode": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        product = 1\n        result = []\n        for num in nums:\n            result.append(product)\n            product *= num\n        product = 1\n        for i in range(len(nums) - 1, -1, -1):\n            result[i] *= product",
    "detail": "__UNSORTED.238",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.239",
    "description": "__UNSORTED.239",
    "peekOfCode": "class Solution:\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        q = deque()\n        ret = []\n        for i, num in enumerate(nums):",
    "detail": "__UNSORTED.239",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.240",
    "description": "__UNSORTED.240",
    "peekOfCode": "class Solution:\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not matrix or len(matrix) == 0 or not matrix[0]:\n            return False\n        m, n = len(matrix), len(matrix[0])",
    "detail": "__UNSORTED.240",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.242",
    "description": "__UNSORTED.242",
    "peekOfCode": "class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        return Counter(s) == Counter(t)",
    "detail": "__UNSORTED.242",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.243",
    "description": "__UNSORTED.243",
    "peekOfCode": "class Solution:\n    def shortestDistance(self, words, word1, word2):\n        \"\"\"\n        :type words: List[str]\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        idx1, idx2 = len(words), len(words)\n        result = len(words)",
    "detail": "__UNSORTED.243",
    "documentation": {}
  },
  {
    "label": "WordDistance",
    "kind": 6,
    "importPath": "__UNSORTED.244",
    "description": "__UNSORTED.244",
    "peekOfCode": "class WordDistance:\n    def __init__(self, words: List[str]):\n        self.d = defaultdict(list)\n        for i, word in enumerate(words):\n            self.d[word].append(i)\n    def shortest(self, word1: str, word2: str) -> int:\n        loc1 = self.d[word1]\n        loc2 = self.d[word2]\n        result = float(\"inf\")\n        i, j = 0, 0",
    "detail": "__UNSORTED.244",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.246",
    "description": "__UNSORTED.246",
    "peekOfCode": "class Solution(object):\n    def isStrobogrammatic(self, num):\n        \"\"\"\n        :type num: str\n        :rtype: bool\n        \"\"\"\n        mapping = {\"6\": \"9\", \"8\": \"8\", \"1\": \"1\", \"9\": \"6\", \"0\": \"0\"}\n        l, r = 0, len(num) - 1\n        while l <= r:\n            if num[l] not in mapping or num[r] not in mapping:",
    "detail": "__UNSORTED.246",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.249",
    "description": "__UNSORTED.249",
    "peekOfCode": "class Solution:\n    def groupStrings(self, strings: List[str]) -> List[List[str]]:\n        d = {}\n        for s in strings:\n            key = []\n            for i in range(1, len(s)):\n                key.append(str((ord(s[i]) - ord(s[i - 1])) % 26))\n            k = \",\".join(key)\n            d[k] = d.get(k, []) + [s]\n        return list(d.values())",
    "detail": "__UNSORTED.249",
    "documentation": {}
  },
  {
    "label": "Vector2D",
    "kind": 6,
    "importPath": "__UNSORTED.251",
    "description": "__UNSORTED.251",
    "peekOfCode": "class Vector2D(object):\n    def __init__(self, vec2d):\n        \"\"\"\n        Initialize your data structure here.\n        :type vec2d: List[List[int]]\n        \"\"\"\n        self.row = 0\n        self.col = 0\n        self.vec2d = vec2d\n    def next(self):",
    "detail": "__UNSORTED.251",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.252",
    "description": "__UNSORTED.252",
    "peekOfCode": "class Solution:\n    def canAttendMeetings(self, intervals: List[List[int]]) -> bool:\n        intervals = sorted(intervals, key=lambda x: x[1])\n        end = -1\n        for interval in intervals:\n            if interval[0] >= end:\n                end = interval[1]\n                continue\n            return False\n        return True",
    "detail": "__UNSORTED.252",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.253",
    "description": "__UNSORTED.253",
    "peekOfCode": "class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        if not intervals:\n            return 0\n        result, curr = 0, 0\n        for i, val in sorted(\n            x for interval in intervals for x in [(interval[0], 1), (interval[1], -1)]\n        ):\n            curr += val\n            result = max(curr, result)",
    "detail": "__UNSORTED.253",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.256",
    "description": "__UNSORTED.256",
    "peekOfCode": "class Solution:\n    def minCost(self, costs):\n        \"\"\"\n        :type costs: List[List[int]]\n        :rtype: int\n        \"\"\"\n        prev = [0] * 3\n        for cost in costs:\n            prev = [cost[i] + min(prev[:i] + prev[i + 1 :]) for i in range(3)]\n        return min(prev)",
    "detail": "__UNSORTED.256",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.257",
    "description": "__UNSORTED.257",
    "peekOfCode": "class Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        if not root:\n            return []\n        paths = []\n        def dfs(root, curr):",
    "detail": "__UNSORTED.257",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.268",
    "description": "__UNSORTED.268",
    "peekOfCode": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        totalSum, n = sum(nums), len(nums)\n        expectedSum = (n * (n + 1)) / 2",
    "detail": "__UNSORTED.268",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.279",
    "description": "__UNSORTED.279",
    "peekOfCode": "class Solution(object):\n    def numSquares(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        mapping = {}\n        squares = [num * num for num in range(1, int(pow(n, 0.5)) + 1)]\n        for square in squares:\n            mapping[square] = 1",
    "detail": "__UNSORTED.279",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "class Solution(object):\n\tdef __init__(self, v1, v2):\n\t\tself.v1 = v1\n\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "v1",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "v1 = [1, 2]\nv2 = [3, 4, 5, 6]\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\n'''\nclass Solution(object):\n\tdef __init__(self, v1, v2):\n\t\tself.v1 = v1\n\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "v2",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "v2 = [3, 4, 5, 6]\nBy calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1, 3, 2, 4, 5, 6].\n'''\nclass Solution(object):\n\tdef __init__(self, v1, v2):\n\t\tself.v1 = v1\n\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\tdef next(self):",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\tself.v1",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\tself.v1 = v1\n\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\tself.v2",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\tself.v2 = v2\n\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\tself.index_v1",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\tself.index_v1 = 0\n\t\tself.index_v2 = 0\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\tself.index_v2",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\tself.index_v2 = 0\n\tdef next(self):\n\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1\n\t\treturn result",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\tresult",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\tresult = -1\n\t\tif self.index_v1 != len(self.v1) and self.index_v1 <= self.index_v2:\n\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1\n\t\treturn result\n\tdef hasNext(self):\n\t\treturn self.index_v1 < len(self.v1) or self.index_v2 < len(self.v2)",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\t\tresult",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\t\tresult = self.v1[self.index_v1]\n\t\t\tself.index_v1 += 1\n\t\telse:\n\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1\n\t\treturn result\n\tdef hasNext(self):\n\t\treturn self.index_v1 < len(self.v1) or self.index_v2 < len(self.v2)\nsolution = Solution([1, 2], [3, 4, 5, 6])\nwhile solution.hasNext():",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "\t\t\tresult",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "\t\t\tresult = self.v2[self.index_v2]\n\t\t\tself.index_v2 += 1\n\t\treturn result\n\tdef hasNext(self):\n\t\treturn self.index_v1 < len(self.v1) or self.index_v2 < len(self.v2)\nsolution = Solution([1, 2], [3, 4, 5, 6])\nwhile solution.hasNext():\n\tprint solution.next()",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "solution",
    "kind": 5,
    "importPath": "__UNSORTED.281",
    "description": "__UNSORTED.281",
    "peekOfCode": "solution = Solution([1, 2], [3, 4, 5, 6])\nwhile solution.hasNext():\n\tprint solution.next()",
    "detail": "__UNSORTED.281",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.283",
    "description": "__UNSORTED.283",
    "peekOfCode": "class Solution(object):\n    def moveZeroes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        zeroIndex = 0\n        for index in range(len(nums)):\n            if nums[index] != 0:\n                nums[zeroIndex] = nums[index]",
    "detail": "__UNSORTED.283",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "class Solution(object):\n    def inorderSuccessor(self, root, p):\n        \"\"\"\n        :type root: TreeNode\n        :type p: TreeNode\n        :rtype: TreeNode\n\t\t\"\"\"\n\t\tif not root or not p:\n\t\t\treturn None\n\t\tif p.right:",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\t\tp",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\t\tp = p.right\n\t\t\twhile p.left:\n\t\t\t\tp = p.left\n\t\t\treturn p\n\t\tsuccessor = None\n\t\twhile root and root != p:\n\t\t\tif root.val > p.val:\n\t\t\t\tsuccessor = root\n\t\t\t\troot = root.left\n\t\t\telse:",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tp",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\t\t\tp = p.left\n\t\t\treturn p\n\t\tsuccessor = None\n\t\twhile root and root != p:\n\t\t\tif root.val > p.val:\n\t\t\t\tsuccessor = root\n\t\t\t\troot = root.left\n\t\t\telse:\n\t\t\t\troot = root.right\n\t\treturn successor",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\tsuccessor",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\tsuccessor = None\n\t\twhile root and root != p:\n\t\t\tif root.val > p.val:\n\t\t\t\tsuccessor = root\n\t\t\t\troot = root.left\n\t\t\telse:\n\t\t\t\troot = root.right\n\t\treturn successor",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\t\t\tsuccessor",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\t\t\tsuccessor = root\n\t\t\t\troot = root.left\n\t\t\telse:\n\t\t\t\troot = root.right\n\t\treturn successor",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\t\t\troot",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\t\t\troot = root.left\n\t\t\telse:\n\t\t\t\troot = root.right\n\t\treturn successor",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "\t\t\t\troot",
    "kind": 5,
    "importPath": "__UNSORTED.285",
    "description": "__UNSORTED.285",
    "peekOfCode": "\t\t\t\troot = root.right\n\t\treturn successor",
    "detail": "__UNSORTED.285",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.287",
    "description": "__UNSORTED.287",
    "peekOfCode": "class Solution(object):\n    def findDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        slow, fast = nums[0], nums[0]\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]",
    "detail": "__UNSORTED.287",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.289",
    "description": "__UNSORTED.289",
    "peekOfCode": "class Solution(object):\n    def gameOfLife(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        \"\"\"\n        index = []\n        def around(i, j, board):\n            count = 0\n            for k in range(i - 1, i + 2):",
    "detail": "__UNSORTED.289",
    "documentation": {}
  },
  {
    "label": "MedianFinder",
    "kind": 6,
    "importPath": "__UNSORTED.295",
    "description": "__UNSORTED.295",
    "peekOfCode": "class MedianFinder(object):\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.max_heap = []\n        self.min_heap = []\n    def addNum(self, num):\n        \"\"\"\n        :type num: int",
    "detail": "__UNSORTED.295",
    "documentation": {}
  },
  {
    "label": "Codec",
    "kind": 6,
    "importPath": "__UNSORTED.297",
    "description": "__UNSORTED.297",
    "peekOfCode": "class Codec:\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        def preorder(root):\n            if root:\n                seralizeTree.append(str(root.val) + \",\")\n                preorder(root.left)",
    "detail": "__UNSORTED.297",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.298",
    "description": "__UNSORTED.298",
    "peekOfCode": "class Solution(object):\n\tdef dfs(curr, parent, length):\n\t\tif not curr:\n\t\t\treturn length\n\t\tif parent:\n\t\t\tlength = length + 1 if curr.val == parent.val + 1\n\t\telse:\n\t\t\tlength = 1\n\t\treturn max(length, max(dfs(curr.left, curr, length), dfs(curr.right, curr, length)))\n\tdef longestConsecutive(TreeNode root):",
    "detail": "__UNSORTED.298",
    "documentation": {}
  },
  {
    "label": "\t\t\tlength",
    "kind": 5,
    "importPath": "__UNSORTED.298",
    "description": "__UNSORTED.298",
    "peekOfCode": "\t\t\tlength = length + 1 if curr.val == parent.val + 1\n\t\telse:\n\t\t\tlength = 1\n\t\treturn max(length, max(dfs(curr.left, curr, length), dfs(curr.right, curr, length)))\n\tdef longestConsecutive(TreeNode root):\n\t\tif not root:\n\t\t\treturn 0\n\t\treturn dfs(root, null, 0)",
    "detail": "__UNSORTED.298",
    "documentation": {}
  },
  {
    "label": "\t\t\tlength",
    "kind": 5,
    "importPath": "__UNSORTED.298",
    "description": "__UNSORTED.298",
    "peekOfCode": "\t\t\tlength = 1\n\t\treturn max(length, max(dfs(curr.left, curr, length), dfs(curr.right, curr, length)))\n\tdef longestConsecutive(TreeNode root):\n\t\tif not root:\n\t\t\treturn 0\n\t\treturn dfs(root, null, 0)",
    "detail": "__UNSORTED.298",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.300",
    "description": "__UNSORTED.300",
    "peekOfCode": "class Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) <= 1:\n            return len(nums)\n        count = [0 for _ in range(len(nums))]\n        result = 1",
    "detail": "__UNSORTED.300",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.43",
    "description": "__UNSORTED.43",
    "peekOfCode": "class Solution:\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        result = [0] * (len(num1) + len(num2))\n        tail = len(result) - 1\n        for n1 in reversed(num1):",
    "detail": "__UNSORTED.43",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.44",
    "description": "__UNSORTED.44",
    "peekOfCode": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        prev = [True]\n        for i in range(len(p)):\n            prev.append(prev[i] and p[i] == \"*\")",
    "detail": "__UNSORTED.44",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.45",
    "description": "__UNSORTED.45",
    "peekOfCode": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        if len(nums) <= 1:\n            return 0\n        jumps = 0\n        curr_state, max_state = 0, 0\n        for i, v in enumerate(nums[:-1]):\n            max_state = max(max_state, i + v)\n            if i == curr_state:\n                jumps += 1",
    "detail": "__UNSORTED.45",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.46",
    "description": "__UNSORTED.46",
    "peekOfCode": "class Solution:\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        ret = []\n        self.dfs(nums, ret, [])\n        return ret\n    def dfs(self, nums, ret, permutation):",
    "detail": "__UNSORTED.46",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.47",
    "description": "__UNSORTED.47",
    "peekOfCode": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        nums.sort()\n        def find(path, A):\n            if len(path) == len(nums):\n                result.append(path)\n                return\n            for i in range(len(A)):\n                if i > 0 and A[i - 1] == A[i]:",
    "detail": "__UNSORTED.47",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.48",
    "description": "__UNSORTED.48",
    "peekOfCode": "class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        visited = set()\n        n = len(matrix)\n        for i in range(n):\n            for j in range(n):\n                if not visited or (i, j) not in visited:",
    "detail": "__UNSORTED.48",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.49",
    "description": "__UNSORTED.49",
    "peekOfCode": "class Solution:\n    def groupAnagrams(self, strs):\n        \"\"\"\n        :type strs: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        if not strs:\n            return []\n        d = defaultdict(list)\n        for s in strs:",
    "detail": "__UNSORTED.49",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.50",
    "description": "__UNSORTED.50",
    "peekOfCode": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        if n == 0:\n            return 1\n        if n < 0:\n            if n == -2147483648:\n                n += 2\n            n = -n\n            x = 1 / x\n        return (",
    "detail": "__UNSORTED.50",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.51",
    "description": "__UNSORTED.51",
    "peekOfCode": "class Solution:\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        def dfs(row):\n            if row == n:\n                ret.append([\"\".join(r) for r in chessboard])\n                return",
    "detail": "__UNSORTED.51",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.52",
    "description": "__UNSORTED.52",
    "peekOfCode": "class Solution:\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        self.ret = 0\n        self.dfs([-1] * n, 0)\n        return self.ret\n    def dfs(self, b, r):",
    "detail": "__UNSORTED.52",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.53",
    "description": "__UNSORTED.53",
    "peekOfCode": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        result, curr_sum = nums[0], nums[0]\n        for num in nums[1:]:\n            curr_sum = max(num, curr_sum + num)\n            result = max(result, curr_sum)\n        return result",
    "detail": "__UNSORTED.53",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.54",
    "description": "__UNSORTED.54",
    "peekOfCode": "class Solution:\n    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:\n        if not matrix or not matrix[0]:\n            return []\n        m, n = len(matrix), len(matrix[0])\n        rowMin, rowMax, colMin, colMax = 0, m - 1, 0, n - 1\n        result = []\n        while rowMin <= rowMax and colMin <= colMax:\n            for j in range(colMin, colMax + 1):\n                result.append(matrix[rowMin][j])",
    "detail": "__UNSORTED.54",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.55",
    "description": "__UNSORTED.55",
    "peekOfCode": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        if len(nums) < 2:\n            return True\n        currentEnd, currentFarthest = 0, 0\n        for i in range(len(nums) - 1):\n            currentFarthest = max(i + nums[i], currentFarthest)\n            if i == currentEnd:\n                currentEnd = currentFarthest\n            if currentEnd >= len(nums) - 1:",
    "detail": "__UNSORTED.55",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.56",
    "description": "__UNSORTED.56",
    "peekOfCode": "class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        if not intervals:\n            return []\n        if len(intervals) < 2:\n            return intervals\n        intervals = sorted(intervals, key=lambda x: x[0])\n        stack = []\n        for interval in intervals:\n            if stack and stack[-1][1] >= interval[0]:",
    "detail": "__UNSORTED.56",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.57",
    "description": "__UNSORTED.57",
    "peekOfCode": "class Solution:\n    def insert(\n        self, intervals: List[List[int]], newInterval: List[int]\n    ) -> List[List[int]]:\n        if not intervals or len(intervals) == 0:\n            return [newInterval]\n        result, i = [], 0\n        while i < len(intervals) and intervals[i][1] < newInterval[0]:\n            result.append(intervals[i])\n            i += 1",
    "detail": "__UNSORTED.57",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.58",
    "description": "__UNSORTED.58",
    "peekOfCode": "class Solution:\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        return len(s.strip().split(\" \")[-1])",
    "detail": "__UNSORTED.58",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.59",
    "description": "__UNSORTED.59",
    "peekOfCode": "class Solution:\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        res = [[0] * n for _ in range(n)]\n        r, c, dr, dc = 0, 0, 0, 1\n        for i in range(1, n * n + 1):\n            res[r][c] = i",
    "detail": "__UNSORTED.59",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.60",
    "description": "__UNSORTED.60",
    "peekOfCode": "class Solution:\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        nums = list(range(1, n + 1))\n        NN = math.factorial(n)\n        k -= 1",
    "detail": "__UNSORTED.60",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.61",
    "description": "__UNSORTED.61",
    "peekOfCode": "class Solution:\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return []\n        l = 1",
    "detail": "__UNSORTED.61",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.62",
    "description": "__UNSORTED.62",
    "peekOfCode": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for row in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[-1]",
    "detail": "__UNSORTED.62",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.63",
    "description": "__UNSORTED.63",
    "peekOfCode": "class Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [0] * n\n        dp[0] = 1\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j >= 1:",
    "detail": "__UNSORTED.63",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.64",
    "description": "__UNSORTED.64",
    "peekOfCode": "class Solution:\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not grid or len(grid) == 0:\n            return 0\n        # Space: O(m*n)\n        # m, n = len(grid), len(grid[0])",
    "detail": "__UNSORTED.64",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.65",
    "description": "__UNSORTED.65",
    "peekOfCode": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        try:\n            new_num = float(s)\n        except:\n            return False",
    "detail": "__UNSORTED.65",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.65",
    "description": "__UNSORTED.65",
    "peekOfCode": "class Solution:\n    def isNumber(self, s: str) -> bool:\n        states = [\n            {\"blank\": 0, \"digit\": 1, \"sign\": 2, \"dot\": 3},\n            {\"digit\": 1, \"dot\": 4, \"e\": 5, \"blank\": 8},\n            {\"digit\": 1, \"dot\": 3},\n            {\"digit\": 4},\n            {\"digit\": 4, \"e\": 5, \"blank\": 8},\n            {\"sign\": 6, \"digit\": 7},\n            {\"digit\": 7},",
    "detail": "__UNSORTED.65",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.66",
    "description": "__UNSORTED.66",
    "peekOfCode": "class Solution:\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        for i in range(len(digits)):\n            digits[~i] += 1\n            if digits[~i] < 10:\n                return digits",
    "detail": "__UNSORTED.66",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.67",
    "description": "__UNSORTED.67",
    "peekOfCode": "class Solution:\n    def addBinary(self, a: str, b: str) -> str:\n        i, j, carry = len(a) - 1, len(b) - 1, 0\n        result = \"\"\n        while i >= 0 or j >= 0 or carry:\n            if i >= 0:\n                carry += int(a[i])\n                i -= 1\n            if j >= 0:\n                carry += int(b[j])",
    "detail": "__UNSORTED.67",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.68",
    "description": "__UNSORTED.68",
    "peekOfCode": "class Solution:\n    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:\n        curr, num_of_chars, result = [], 0, []\n        for word in words:\n            # len(curr) represent the number of spaces following total words\n            if len(curr) + num_of_chars + len(word) > maxWidth:\n                for i in range(maxWidth - num_of_chars):\n                    curr[i % (len(curr) - 1 or 1)] += \" \"\n                result.append(\"\".join(curr))\n                curr = []",
    "detail": "__UNSORTED.68",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.69",
    "description": "__UNSORTED.69",
    "peekOfCode": "class Solution:\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        if x == 0:\n            return 0\n        left, right = 1, x\n        while left <= right:",
    "detail": "__UNSORTED.69",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.70",
    "description": "__UNSORTED.70",
    "peekOfCode": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 1:\n            return n\n        s1 = 1\n        s2 = 2\n        for i in range(2, n):\n            s = s1 + s2\n            s1, s2 = s2, s\n        return s2",
    "detail": "__UNSORTED.70",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.71",
    "description": "__UNSORTED.71",
    "peekOfCode": "class Solution:\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        for p in path.split(\"/\"):\n            if p == \"..\":\n                if stack:",
    "detail": "__UNSORTED.71",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.72",
    "description": "__UNSORTED.72",
    "peekOfCode": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        prev = [0]\n        m, n = len(word2), len(word1)\n        for i in range(n):\n            prev.append(prev[i] + 1)\n        for i in range(m):\n            curr = [i + 1]\n            for j in range(n):\n                tmp = prev[j] if word1[j] == word2[i] else prev[j] + 1",
    "detail": "__UNSORTED.72",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.73",
    "description": "__UNSORTED.73",
    "peekOfCode": "class Solution:\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        m = len(matrix)\n        if m == 0:\n            return\n        n = len(matrix[0])",
    "detail": "__UNSORTED.73",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.74",
    "description": "__UNSORTED.74",
    "peekOfCode": "class Solution:\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if len(matrix) == 0 or len(matrix[0]) == 0:\n            return False\n        m, n = len(matrix), len(matrix[0])",
    "detail": "__UNSORTED.74",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.75",
    "description": "__UNSORTED.75",
    "peekOfCode": "class Solution:\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i, j = 0, 0\n        for k in range(len(nums)):\n            v = nums[k]\n            nums[k] = 2",
    "detail": "__UNSORTED.75",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.76",
    "description": "__UNSORTED.76",
    "peekOfCode": "class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        d = Counter(t)\n        start, end = 0, 0\n        result = \"\"\n        count = len(d)\n        while end < len(s):\n            c = s[end]\n            if c in d:\n                d[c] -= 1",
    "detail": "__UNSORTED.76",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.77",
    "description": "__UNSORTED.77",
    "peekOfCode": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        result = []\n        self.dfs(list(range(1, n + 1)), k, [], result)\n        return result\n    def dfs(self, arr, k, path, result):\n        if k < 0:\n            return\n        if k == 0:\n            result.append(path)",
    "detail": "__UNSORTED.77",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.78",
    "description": "__UNSORTED.78",
    "peekOfCode": "class Solution:\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        result = []\n        for i in range(1 << len(nums)):\n            tmp = []\n            for j in range(len(nums)):",
    "detail": "__UNSORTED.78",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.78",
    "description": "__UNSORTED.78",
    "peekOfCode": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        self.backtrack(result, 0, nums, [])\n        return result\n    def backtrack(self, result, idx, nums, path):\n        result.append(path)\n        for i in range(idx, len(nums)):\n            self.backtrack(result, i + 1, nums, path + [nums[i]])",
    "detail": "__UNSORTED.78",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.79",
    "description": "__UNSORTED.79",
    "peekOfCode": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if self.dfs(board, i, j, set(), word, 0):\n                    return True\n        return False\n    def dfs(self, board, x, y, visited, word, idx):\n        if idx == len(word):\n            return True",
    "detail": "__UNSORTED.79",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.80",
    "description": "__UNSORTED.80",
    "peekOfCode": "class Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        if len(nums) == 1:\n            return 1",
    "detail": "__UNSORTED.80",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.81",
    "description": "__UNSORTED.81",
    "peekOfCode": "class Solution:\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        if not nums:\n            return False\n        l, r = 0, len(nums) - 1",
    "detail": "__UNSORTED.81",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.82",
    "description": "__UNSORTED.82",
    "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = prev = ListNode(0)\n        dummy.next = head\n        while head and head.next:\n            if head.val == head.next.val:",
    "detail": "__UNSORTED.82",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.83",
    "description": "__UNSORTED.83",
    "peekOfCode": "class Solution:\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        dummy = prev = ListNode(0)\n        dummy.next = head\n        while head and head.next:\n            if head.val == head.next.val:",
    "detail": "__UNSORTED.83",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.84",
    "description": "__UNSORTED.84",
    "peekOfCode": "class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        heights += [0]\n        stack = [-1]\n        result = 0\n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                result = max(result, h * (i - stack[-1] - 1))\n            stack.append(i)",
    "detail": "__UNSORTED.84",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.85",
    "description": "__UNSORTED.85",
    "peekOfCode": "class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix or len(matrix[0]) == 0:\n            return 0\n        result, n = 0, len(matrix[0])\n        heights = [0] * (n + 1)\n        for row in matrix:\n            for i in range(n):\n                heights[i] = heights[i] + 1 if row[i] == \"1\" else 0\n            stack = [-1]",
    "detail": "__UNSORTED.85",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.86",
    "description": "__UNSORTED.86",
    "peekOfCode": "class Solution:\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        dummy1 = prev = ListNode(0)\n        dummy2 = after = ListNode(0)\n        while head:",
    "detail": "__UNSORTED.86",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.87",
    "description": "__UNSORTED.87",
    "peekOfCode": "class Solution:\n    def __init__(self):\n        self.memo = {}\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        if (s1, s2) in self.memo:",
    "detail": "__UNSORTED.87",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.88",
    "description": "__UNSORTED.88",
    "peekOfCode": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: void Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        while m > 0 and n > 0:",
    "detail": "__UNSORTED.88",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.90",
    "description": "__UNSORTED.90",
    "peekOfCode": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        result = []\n        self.backtrack(sorted(nums), [], result)\n        return result\n    def backtrack(self, nums, path, result):\n        result.append(path)\n        if not nums:\n            return\n        for i in range(len(nums)):",
    "detail": "__UNSORTED.90",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.91",
    "description": "__UNSORTED.91",
    "peekOfCode": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(n):\n            if s[i] > \"0\":\n                dp[i + 1] += dp[i]\n            if i > 0 and \"10\" <= s[i - 1 : i + 1] <= \"26\":\n                dp[i + 1] += dp[i - 1]",
    "detail": "__UNSORTED.91",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.92",
    "description": "__UNSORTED.92",
    "peekOfCode": "class Solution:\n    def reverseBetween(self, head, m, n):\n        \"\"\"\n        :type head: ListNode\n        :type m: int\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        if not head:\n            return None",
    "detail": "__UNSORTED.92",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.93",
    "description": "__UNSORTED.93",
    "peekOfCode": "class Solution:\n    def restoreIpAddresses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        res = []\n        self.dfs(res, s, 0, \"\", 0)\n        return res\n    def dfs(self, res, s, secNum, sec, idx):",
    "detail": "__UNSORTED.93",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.94",
    "description": "__UNSORTED.94",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\nclass Solution:\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]",
    "detail": "__UNSORTED.94",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.94",
    "description": "__UNSORTED.94",
    "peekOfCode": "class Solution:\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        if not root:\n            return []\n        return (\n            self.inorderTraversal(root.left)",
    "detail": "__UNSORTED.94",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.94",
    "description": "__UNSORTED.94",
    "peekOfCode": "class Solution:\n    def inorderTraversal(self, root: TreeNode) -> List[int]:\n        stack, curr = [], root\n        result = []\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            top = stack.pop()\n            result.append(top.val)",
    "detail": "__UNSORTED.94",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.95",
    "description": "__UNSORTED.95",
    "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        if n == 0:\n            return []\n        self.trees = {}",
    "detail": "__UNSORTED.95",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.95",
    "description": "__UNSORTED.95",
    "peekOfCode": "class Solution:\n    def generateTrees(self, n: int) -> List[TreeNode]:\n        if n == 0:\n            return []\n        self.trees = {}\n        return self.constructTree(1, n)\n    def constructTree(self, start, end):\n        if (start, end) in self.trees:\n            return self.trees[(start, end)]\n        if start > end:",
    "detail": "__UNSORTED.95",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.96",
    "description": "__UNSORTED.96",
    "peekOfCode": "class Solution:\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        # DP[n]: number of BST of a sequence with length n\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):",
    "detail": "__UNSORTED.96",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.97",
    "description": "__UNSORTED.97",
    "peekOfCode": "class Solution:\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        # m, n = len(s1), len(s2)\n        # if len(s3) != m+n: return False",
    "detail": "__UNSORTED.97",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.98",
    "description": "__UNSORTED.98",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n# class Solution:\n#     def isValidBST(self, root: TreeNode) -> bool:\n#         return self.isValid(root, float('-inf'), float('inf'))\n#     def isValid(self, root, lower, upper):\n#         if not root: return True",
    "detail": "__UNSORTED.98",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.98",
    "description": "__UNSORTED.98",
    "peekOfCode": "class Solution:\n    def isValidBST(self, root: TreeNode) -> bool:\n        stack, curr, prev = [], root, None\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            top = stack.pop()\n            if prev and prev.val >= top.val:\n                return False",
    "detail": "__UNSORTED.98",
    "documentation": {}
  },
  {
    "label": "TreeNode",
    "kind": 6,
    "importPath": "__UNSORTED.99",
    "description": "__UNSORTED.99",
    "peekOfCode": "class TreeNode:\n    def __init__(self, x):\n        self.val = x\n        self.left = None\n        self.right = None\n# Space: O(h), where h is the tree height\nclass Solution:\n    def __init__(self):\n        self.prev = TreeNode(float(\"-inf\"))\n        self.first = None",
    "detail": "__UNSORTED.99",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.99",
    "description": "__UNSORTED.99",
    "peekOfCode": "class Solution:\n    def __init__(self):\n        self.prev = TreeNode(float(\"-inf\"))\n        self.first = None\n        self.second = None\n    def recoverTree(self, root: TreeNode) -> None:\n        \"\"\"\n        Do not return anything, modify root in-place instead.\n        \"\"\"\n        self.traverse(root)",
    "detail": "__UNSORTED.99",
    "documentation": {}
  },
  {
    "label": "Solution1",
    "kind": 6,
    "importPath": "__UNSORTED.99",
    "description": "__UNSORTED.99",
    "peekOfCode": "class Solution1:\n    def __init__(self):\n        self.previous = TreeNode(float(\"-inf\"))\n        self.first = None\n        self.second = None\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: void Do not return anything, modify root in-place instead.\n        \"\"\"",
    "detail": "__UNSORTED.99",
    "documentation": {}
  },
  {
    "label": "Solution",
    "kind": 6,
    "importPath": "__UNSORTED.TwoSum",
    "description": "__UNSORTED.TwoSum",
    "peekOfCode": "class Solution(object):\n    def twoSum(self, nums, target):\n        mapping = {}\n        for index, val in enumerate(nums):\n            diff = target - val\n            if diff in mapping:\n                return [index, mapping[diff]]\n            else:\n                mapping[val] = index\n# Space: O(N)",
    "detail": "__UNSORTED.TwoSum",
    "documentation": {}
  },
  {
    "label": "process_dir",
    "kind": 2,
    "importPath": "dirhtml",
    "description": "dirhtml",
    "peekOfCode": "def process_dir(top_dir, opts):\n    glob_patt = opts.filter or '*'\n    path_top_dir: Path\n    path_top_dir = Path(top_dir)\n    index_file = None\n    index_path = Path(path_top_dir, opts.output_file)\n    if opts.verbose:\n        print(f'Traversing dir {path_top_dir.absolute()}')\n    try:\n        index_file = open(index_path, 'w')",
    "detail": "dirhtml",
    "documentation": {}
  },
  {
    "label": "pretty_size",
    "kind": 2,
    "importPath": "dirhtml",
    "description": "dirhtml",
    "peekOfCode": "def pretty_size(bytes, units=UNITS_MAPPING):\n    \"\"\"Human-readable file sizes.\n    ripped from https://pypi.python.org/pypi/hurry.filesize/\n    \"\"\"\n    for factor, suffix in units:\n        if bytes >= factor:\n            break\n    amount = int(bytes / factor)\n    if isinstance(suffix, tuple):\n        singular, multiple = suffix",
    "detail": "dirhtml",
    "documentation": {}
  },
  {
    "label": "DEFAULT_OUTPUT_FILE",
    "kind": 5,
    "importPath": "dirhtml",
    "description": "dirhtml",
    "peekOfCode": "DEFAULT_OUTPUT_FILE = 'index.html'\ndef process_dir(top_dir, opts):\n    glob_patt = opts.filter or '*'\n    path_top_dir: Path\n    path_top_dir = Path(top_dir)\n    index_file = None\n    index_path = Path(path_top_dir, opts.output_file)\n    if opts.verbose:\n        print(f'Traversing dir {path_top_dir.absolute()}')\n    try:",
    "detail": "dirhtml",
    "documentation": {}
  },
  {
    "label": "UNITS_MAPPING",
    "kind": 5,
    "importPath": "dirhtml",
    "description": "dirhtml",
    "peekOfCode": "UNITS_MAPPING = [\n    (1024 ** 5, ' PB'),\n    (1024 ** 4, ' TB'),\n    (1024 ** 3, ' GB'),\n    (1024 ** 2, ' MB'),\n    (1024 ** 1, ' KB'),\n    (1024 ** 0, (' byte', ' bytes')),\n]\ndef pretty_size(bytes, units=UNITS_MAPPING):\n    \"\"\"Human-readable file sizes.",
    "detail": "dirhtml",
    "documentation": {}
  }
]
